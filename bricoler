#!/usr/bin/env lua54

--
-- Copyright (c) Mark Johnston <markj@FreeBSD.org>
--
-- SPDX-License-Identifier: BSD-2-Clause
--

local scriptdir = arg[0]:match("(.+)/[^/]+$")
package.path = package.path .. ";" .. scriptdir .. "/?.lua"

package.path = package.path .. ";" .. scriptdir .. "/contrib/orch/install/share/lua/5.4/?.lua"
package.cpath = package.cpath .. ";" .. scriptdir .. "/contrib/orch/install/lib/lua/5.4/?.so"
local orch = require 'orch'

-------------------------------- Lua helpers -------------------------

local function _errx(s, ...)
    error(string.format(s, ...))
end

local function printf(fmt, ...)
    print(string.format(fmt, ...))
end

local function sprintf(fmt, ...)
    return string.format(fmt, ...)
end

local function ansicolor(str, color)
    local c = {
        black = 30,
        red = 31,
        green = 32,
        yellow = 33,
        blue = 34,
        magenta = 35,
        cyan = 36,
        white = 37,
    }
    local s = c[color]
    if not s then
        _errx("Invalid color: %s", color)
    end
    return "\027[" .. tostring(s) .. "m" .. str .. "\027[0m"
end

local function errx(s, ...)
    _errx(ansicolor("ERROR", "red") .. ": " .. s, ...)
end

local function octal(n)
    return tonumber(n, 8)
end

-- A dumb string formatter which takes a format string and a table of key-value
-- pairs.  The string "$key" in the format string is replaced by the value of
-- that key.  Currently there is no support for escaping.
local function substitute(s, vars)
    return s:gsub("%$([%w_]+)", vars)
end

function io.open_checked(path, mode)
    local f, errstr = io.open(path, mode)
    if not f then
        errx("Failed to open %s: %s", path, errstr)
    end
    return f
end

function table.append(t1, ...)
    local t2 = {...}
    for _, v in ipairs(t2) do
        table.insert(t1, v)
    end
    return t1
end

function table.prepend(t1, ...)
    local t2 = {...}
    for i = #t2, 1, -1 do
        table.insert(t1, 1, t2[i])
    end
    return t1
end

function table.deepcopy(t)
    local function _deepcopy(from, to)
        for k, v in pairs(from) do
            if type(v) == "table" then
                v = _deepcopy(v, {})
            end
            to[k] = v
        end
        return to
    end
    return _deepcopy(t, {})
end

-- Make a new table containing all of the KVPs from the input tables.
-- If a key is present in multiple tables, the value from the last table is
-- used.
function table.merge(t, ...)
    local ret = {}
    for k, v in pairs(t) do
        ret[k] = v
    end
    for _, u in ipairs({...}) do
        for k, v in pairs(u) do
            ret[k] = v
        end
    end
    return ret
end

-- Return an array of the keys shared by all input tables.
function table.intersection(t1, ...)
    local t = table.keys(t1)
    for _, u in ipairs({...}) do
        for k, _ in pairs(t) do
            if not u[k] then
                t[k] = nil
            end
        end
    end
    return t
end

-- Return an array of the keys belonging to all input tables.
function table.union(...)
    local t = {}
    for _, u in ipairs({...}) do
        for k, _ in pairs(u) do
            t[k] = true
        end
    end
    return t
end

-- Return an array of the keys in table t.
function table.keys(t)
    local keys = {}
    for k, _ in pairs(t) do
        table.insert(keys, k)
    end
    return keys
end

-- Return a string representation of a table.
function table.pretty(t, maxdepth)
    local function _pretty(_t, _maxdepth, _depth)
        if _depth == _maxdepth then
            return ""
        end
        local indent = _depth * 2
        local s = ""
        for k, v in pairs(_t) do
            if type(v) == "table" then
                s = s .. string.rep(" ", indent) .. k .. "={\n"
                s = s .. _pretty(v, _maxdepth, _depth + 1)
                s = s .. string.rep(" ", indent) .. "}\n"
            else
                local fv = type(v) == "string" and '"' .. v .. '"' or tostring(v)
                s = s .. string.rep(" ", indent) .. k .. "=" .. fv .. "\n"
            end
        end
        return s
    end
    return _pretty(t, maxdepth, 0)
end

local function orch_spawn(...)
    print(("%s: %s"):format(ansicolor("ORCH", "green"), table.concat({...}, " ")))
    local o = orch.spawn(...)
    if o == nil then
        errx("Failed to spawn orch")
    end
    return o
end

-------------------------------- sys helpers -------------------------
-- Miscellaneous low-level system helper functions.  In general these raise an
-- error if any system call fails.

local _access = require 'lib.freebsd.sys'.access
local _chdir = require 'lib.freebsd.sys'.chdir
local _errno = require 'lib.freebsd.sys'.errno
local getaddrinfo = require 'lib.freebsd.sys'.getaddrinfo
local glob = require 'lib.freebsd.sys'.glob
local _getcwd = require 'lib.freebsd.sys'.getcwd
local _getuid = require 'lib.freebsd.sys'.getuid
local libgen = require 'lib.freebsd.sys'.libgen
local _mkdir = require 'lib.freebsd.sys'.mkdir
local _open = require 'lib.freebsd.sys'.open
local _pipe = require 'lib.freebsd.sys'.pipe
local _poll = require 'lib.freebsd.sys'.poll
local posix_spawn = require 'lib.freebsd.sys'.posix_spawn
local _read = require 'lib.freebsd.sys'.read
local _socket = require 'lib.freebsd.sys'.socket
local _stat = require 'lib.freebsd.sys'.stat
local _symlink = require 'lib.freebsd.sys'.symlink
local _sysctl = require 'lib.freebsd.sys'.sysctl
local _unlink = require 'lib.freebsd.sys'.unlink
local _wait = require 'lib.freebsd.sys'.wait

local function access(path, mode)
    local amode = 0
    for c in mode:gmatch(".") do
        if c == "r" then
            amode = amode + _access.R_OK
        elseif c == "w" then
            amode = amode + _access.W_OK
        elseif c == "x" then
            amode = amode + _access.X_OK
        else
            errx("Invalid mode character '%s'", c)
        end
    end
    return _access.access(path, amode)
end

local function pwd()
    return _getcwd.getcwd()
end

local function cd(path)
    local oldcwd = pwd()
    local res, errstr = _chdir.chdir(path)
    if not res then
        errx("Failed to change directory to %s: %s", path, errstr)
    end
    return oldcwd
end

local function close(fd)
    local res, errstr = _open.close(fd)
    if not res then
        errx("Failed to close fd: %s", errstr)
    end
end

-- Checked process execution.  e.g., exec("ls", "-l", "/").
--
-- The last argument may optionally be an array of "VAR=VAL" environment
-- variables, in which case the process is executed with that as the
-- environment instead of inheriting it.  Use environ() to get a copy of the
-- current environment in this case.
local function _exec(p, ...)
    local args = {p, ...}
    local env = nil
    if type(args[#args]) == "table" then
        env = args[#args]
        args[#args] = nil
    end
    print(("%s: %s"):format(ansicolor("EXEC", "green"), table.concat(args, " ")))
    local pid, errstr = posix_spawn.posix_spawnp(p, args, env)
    if not pid then
        errx("Failed to run %s: %s", p, errstr)
    end

    return _wait.waitpid(pid)
end

local function exec(p, ...)
    local ret, status, num = _exec(p, ...)
    if not ret then
        errx("Failed to wait for %s: %s", p, status)
    elseif status == "signaled" then
        errx("Process %s exited on signal: %d", p, num)
    elseif status == "exited" and num ~= 0 then
        errx("Process %s exited with status: %d", p, num)
    end
end

local function _rootexec(...)
    print(("%s: %s"):format(ansicolor("PRIV", "yellow"), table.concat({...}, " ")))
    return _exec("sudo", ...)
end

local function rootexec(...)
    print(("%s: %s"):format(ansicolor("PRIV", "yellow"), table.concat({...}, " ")))
    exec("sudo", ...)
end

local function mkdir(path, mode)
    return _mkdir.mkdir(path, mode or octal("0755"))
end

-- Make a directory, don't fail if it already exists.  Morally equivalent to
-- mkdir -p.
local function makepath(path, mode)
    local root = path:match("^/") and "/" or "./"
    path = root .. path
    for component in path:gmatch("[^/]+") do
        root = root .. "/" .. component
        local sb = _stat.stat(root)
        if not sb then
            mkdir(root, mode)
        elseif not _stat.S_ISDIR(sb.mode) then
            errx("Path %s is not a directory", root)
        end
    end
end

-- Create a directory and cd into it.
local function mkdircd(path)
    makepath(path)
    cd(path)
end

-- Run a command, waiting until it completes and returning its standard output
-- and standard error.  All output is buffered in memory, so don't use it for
-- large output.
--
-- This waits until the command exits before returning, and raises an error for
-- abnormal exits.
local function runcmd(p, ...)
    local args = {p, ...}
    print(("%s: %s"):format(ansicolor("EXEC", "green"), table.concat(args, " ")))

    local stdout1, stdout2 = _pipe.pipe()
    local stderr1, stderr2 = _pipe.pipe()

    local fa, errstr = posix_spawn.posix_spawn_file_actions_init()
    if not fa then
        errx("Failed to create file actions: %s", errstr)
    end

    local function addfa(f, ...)
        _, errstr = f(...)
        if errstr then
            errx("Failed to add file action: %s", errstr)
        end
    end
    addfa(posix_spawn.posix_spawn_file_actions_adddup2, fa, stdout2, 1)
    addfa(posix_spawn.posix_spawn_file_actions_adddup2, fa, stderr2, 2)
    addfa(posix_spawn.posix_spawn_file_actions_addclose, fa, stdout1)
    addfa(posix_spawn.posix_spawn_file_actions_addclose, fa, stderr1)
    addfa(posix_spawn.posix_spawn_file_actions_addclose, fa, stdout2)
    addfa(posix_spawn.posix_spawn_file_actions_addclose, fa, stderr2)

    local pid
    pid, errstr = posix_spawn.posix_spawnp(p, fa, args)
    if not pid then
        errx("Failed to run %s: %s", p, errstr)
    end

    close(stdout2)
    close(stderr2)

    local pollfds = {
        {fd = stdout1, events = _poll.POLLIN, buf = ""},
        {fd = stderr1, events = _poll.POLLIN, buf = ""},
    }
    local closed = 0
    repeat
        local res
        res, errstr = _poll.poll(pollfds, -1)
        if not res then
            errx("Failed to poll: %s", errstr)
        end

        for _, fd in ipairs(pollfds) do
            if fd.revents & _poll.POLLIN then
                repeat
                    local buf
                    buf, errstr = _read.read(fd.fd, 4096)
                    if not buf then
                        errx("Failed to read from fd: %s", errstr)
                    end
                    fd.buf = fd.buf .. buf
                until buf == ""
            end
            if fd.revents & _poll.POLLHUP then
                fd.fd = -1
                closed = closed + 1
            end
        end
    until closed == #pollfds

    local ret, status, num = _wait.waitpid(pid)
    if not ret then
        errx("Failed to wait for %s: %s", p, status)
    elseif status == "signaled" then
        errx("Process %s exited on signal: %d", p, num)
    elseif status == "exited" and num ~= 0 then
        errx("Process %s exited with status: %d", p, num)
    end

    return pollfds[1].buf, pollfds[2].buf
end

local function cdruncmd(path, p, ...)
    local oldcwd = cd(path)
    local stdout, stderr = runcmd(p, ...)
    cd(oldcwd)
    return stdout, stderr
end

-- Find an unused v4 TCP port that we can listen on.
local function unused_tcp_port(addr)
    local s = _socket.socket(_socket.PF_INET, _socket.SOCK_STREAM, 0)
    if not s then
        errx("Failed to create socket")
    end

    for _ = 0, 10000 do
        local rand = math.random(1024, 65535)
        local hint = {
            family = _socket.PF_INET,
            socktype = _socket.SOCK_STREAM,
            flags = _socket.AI_PASSIVE,
        }
        local t = getaddrinfo.getaddrinfo(addr, rand, hint)
        if #t == 0 then
            errx("Failed to resolve address")
        end
        local res = _socket.bind(s, t[1].addr)
        if res then
            close(s)
            return addr .. ":" .. rand
        end
    end
    errx("Failed to find an unused TCP port")
end

-- Return the environment as an array of "VAR=VAL" strings.  Additional
-- parameters are added to the environment.
local function environ(...)
    local env = {...}
    local stdout = runcmd("env", "-0")
    for line in stdout:gmatch("[^\0]+") do
        table.insert(env, line)
    end
    return env
end

-- Return true if an interface with the given name exists.  At some point this
-- needs to be re-implemented using libifconfig.
local function netif_exists(iface, group)
    local list
    if group then
        list = runcmd("ifconfig", "-g", group)
    else
        list = runcmd("ifconfig", "-l")
    end
    for line in list:gmatch("%S+") do
        if line == iface then
            return true
        end
    end
    return false
end

local function isfile(path)
    local sb = _stat.stat(path)
    return sb and _stat.S_ISREG(sb.mode)
end

local function zfs_get(path, prop)
    local stdout = runcmd("zfs", "get", "-H", "-o", "value", prop, path)
    return stdout:match("%S+")
end

local function symlink(target, link)
    return _symlink.symlink(target, link)
end

local function sysctl(name)
    return _sysctl.sysctlbyname(name)
end

local function host_machine()
    return sysctl("hw.machine") .. "/" .. sysctl("hw.machine_arch")
end

local function which(p)
    local PATH = os.getenv("PATH")
    if PATH == nil then
        errx("PATH environment variable is unset")
    end
    for path in PATH:gmatch("([^:]+)") do
        local candidate = path .. "/" .. p
        if isfile(candidate) and access(candidate, "rx") then
            return candidate
        end
    end
end

local function writefile(path, contents)
    local f = io.open_checked(path, "w+")
    f:write(contents)
    f:close()
end

local function unlink(path)
    return _unlink.unlink(path)
end

-------------------------------- Utility Classes ---------------------

local Class = require 'class'

local MTree = Class({
    defaults = {},
    _entries = {},
    signature = "#mtree 2.0",
}, {
    -- Default values for file entries.
    defaults = "table",
    -- Path to the input mtree file, or an array of input mtree paths.
    src = "*",
    -- Root of the hierarchy defined by the mtree.
    root = "string",
})

function MTree:_load(src)
    local f = io.open_checked(src, "r")

    -- If we have more than one input file, only require the signature to be in
    -- the first file.
    if #self._entries == 0 then
        local sig = f:read("l")
        if not sig then
            errx("Failed to read mtree signature")
        elseif sig ~= self.signature then
            errx("Unsupported mtree signature '%s'", sig)
        end
    end

    -- Parse each line in the mtree file, e.g.,
    --   ./bin type=dir uname=root gname=wheel mode=0755
    -- Each line yields a table of key-value pairs.  The first element is saved
    -- in the table as well, keyed by "path".  The order of lines is preserved.
    -- We assume a flat mtree file, as generated by "mtree -C".
    for line in f:lines() do
        if line:match("^%s*#") then
            goto nextline
        end
        local entry = {}
        for k, v in line:gmatch("(%w+)=(%S+)") do
            entry[k] = v
        end
        entry.path = line:match("^(%S+)")
        if entry.path == nil then
            errx("Invalid mtree line: %s", line)
        end
        table.insert(self._entries, entry)
        ::nextline::
    end
    f:close()
end

-- Load an mtree file into memory.
function MTree:_ctor(args)
    local srcs = (type(args.src) == "string" and {args.src} or args.src)
    for _, src in ipairs(srcs) do
        self:_load(src)
    end
end

function MTree:add(path)
    local fullpath = self.root .. "/" .. path
    local sb = _stat.lstat(fullpath)
    if not sb then
        errx("Failed to stat %s", fullpath)
    end

    local mode = ("%04o"):format(sb.mode & 0x1ff)
    local type = ""
    if _stat.S_ISDIR(sb.mode) then
        type = "dir"
    elseif _stat.S_ISREG(sb.mode) then
        type = "file"
    elseif _stat.S_ISLNK(sb.mode) then
        type = "link"
    else
        errx("Path %s is not a directory, symlink, or regular file", fullpath)
    end
    table.insert(self._entries, {
        path = path,
        mode = mode,
        type = type,
        uname = self.defaults.uname,
        gname = self.defaults.gname,
        link = type == "link" and _symlink.readlink(fullpath) or nil,
    })
end

function MTree:filter(f)
    local entries = {}
    for _, entry in ipairs(self._entries) do
        if f(entry) then
            table.insert(entries, entry)
        end
    end
    self._entries = entries
end

function MTree:stage(tmpfile, rootdir, reldir)
    local targetdir = rootdir .. "/" .. reldir
    local function write_buffer(file, buf)
        local f = io.open_checked(file, "w+")
        f:write(buf)
        f:close()
    end
    local out = runcmd("mtree", "-c", "-p", targetdir)
    write_buffer(tmpfile, out)
    out = runcmd("mtree", "-C", "-p", targetdir, "-f", tmpfile)
    write_buffer(tmpfile, out)

    local f = io.open_checked(tmpfile, "r")
    for line in f:lines() do
        if not line:match("^%s*#") then
            local path = line:match("^%S+")
            local prefix = "./" .. reldir
            if path == "." then
                -- makefs will reject a path like "./foo/.".
                self:add(prefix)
            else
                self:add(prefix .. "/" .. path)
            end
        end
    end
    f:close()
end

function MTree:map(f)
    local entries = {}
    for _, entry in ipairs(self._entries) do
        table.insert(entries, f(entry))
    end
    self._entries = entries
end

-- Write the in-memory mtree to a file.
function MTree:write(path)
    local f = io.open_checked(path, "w+")
    f:write(self.signature .. "\n")
    for _, entry in ipairs(self._entries) do
        local line = entry.path
        for k, v in pairs(entry) do
            if k ~= "path" then
                line = line .. " " .. k .. "=" .. v
            end
        end
        f:write(line .. "\n")
    end
    f:close()
end

local GitRepository = {}

function GitRepository.checked_out_branch(path)
    local stdout = runcmd("git", "-C", path, "rev-parse", "--abbrev-ref", "HEAD")
    return stdout:match("%S+")
end

function GitRepository.clone_or_update(path, params)
    local branch, url = params.branch, params.url
    local sb, err, errno = _stat.stat(path)
    if not sb then
        if errno ~= _errno.ENOENT then
            errx("Failed to stat %s: %s", path, err)
        end
        exec("git", "clone", "--branch=" .. branch, url, path)
    else
        if not _stat.S_ISDIR(sb.mode) then
            errx("Path %s is not a directory", path)
        end
        local oldcwd = cd(path)
        exec("git", "fetch")
        do
            -- Don't do anything if there are local changes.  A more useful
            -- behaviour might be to stash them and apply after the update. 
            local status = runcmd("git", "diff", "--stat")
            if status ~= "" then
                errx("Repository %s has local changes", path)
            end
        end
        exec("git", "reset", "--hard", "origin/" .. branch)
        cd(oldcwd)
    end
end

function GitRepository.task_parameters()
    return {
        branch = {
            description = "The branch to check out when cloning",
        },
        url = {
            description = "A URL for the repository; provide a path to use an existing clone",
            required = true,
            type = "string",
        },
    }
end

local VMRun = Class({
    vm = {},
}, {
    -- The block device driver to use.
    block_driver = "string",
    -- Name of the CPU to emulate.
    cpu = "string",
    -- A list of extra files to add as disks.
    disk_list = "string",
    -- The hyperisor to use.
    hypervisor = "string",
    -- Path to the VM's disk image.
    image = "string",
    -- Run QEMU in its own pty (using orch)?
    interactive = "boolean",
    -- Name of the QEMU machine to emulate.
    machine = "string",
    -- The machine type of the image, e.g., arm64/aarch64.
    machine_tuple = "string",
    -- How much memory to allocate to the VM, in MB.
    memory = "number",
    -- The number of CPUs to allocate to the VM.
    ncpus = "number",
    -- The NIC driver to use.
    nic_driver = "string",
    -- A list of <share>:<path> pairs to mount with 9pfs.
    p9fs_shares = "string",
    -- TAP interfaces to open in the VM.
    tap_list = "string",
    -- The addr:port on which to listen for SSH connections.
    ssh_addr = function (v) return v:match("^[^:]+:%d+$") end,
    -- The addr:port on which to listen for gdb connections.
    gdb_addr = function (v) return v:match("^[^:]+:%d+$") end,
    -- The name of the VM.
    vmname = "string",
})

-- Provide a standard set of parameters for tasks which start a VM.
--
-- Unfortunately, we cannot currently define default values for "bios", "cpu"
-- and "machine" here since they are platform-dependent.
function VMRun.task_parameters()
    return {
        bios = {
            description = "Path to the firmware image to use",
            type = "string",
        },
        block_driver = {
            description = "The block device driver to use",
            valid = {"virtio", "ahci", "nvme"},
            default = "virtio",
        },
        cpu = {
            -- This parameter is really only defined for QEMU.
            description = "The CPU to emulate",
            type = "string",
        },
        disk_list = {
            description = "Additional files to add as disks",
            default = "",
        },
        hypervisor = {
            description = "The hypervisor to use",
            valid = {"bhyve", "qemu"},
            default = "qemu",
        },
        interactive = {
            description = "Run QEMU interactively",
            default = true,
        },
        machine = {
            -- This parameter is really only defined for QEMU.
            description = "The QEMU machine type to emulate",
            type = "string",
        },
        memory = {
            description = "Amount of memory to allocate to the VM, in MB",
            type = "number",
        },
        ncpus = {
            description = "Number of virtual CPUs to allocate to the VM",
            type = "number",
        },
        nic_driver = {
            description = "The device model to use for the NIC",
            valid = {"virtio", "e1000"},
            default = "virtio",
        },
        p9fs_shares = {
            description = "A list of <share>:<path> pairs to mount with 9pfs",
            default = "",
        },
        tap_list = {
            description = "TAP interfaces to open",
            default = "",
        },
        vmname = {
            description = "Name of the VM (relevant for bhyve only)",
            default = "bricoler",
        },
    }
end

function VMRun:boot()
    self.vm:boot()
    if not self.interactive then
        self.vm.orch:log("/dev/stdout")
        -- Booting might be slow since it has to install packages.
        --
        -- The orch documentation seems to suggest that the timeout should
        -- be updated using a function call, but apparently not...?
        self.vm.orch.timeout = 5 * 60
        self.vm.orch:release()
        if not self.vm.orch:match("login:") then
            errx("VM boot timed out")
        end
        self.vm.orch:write("root\n")
        self.vm.orch:match("root@.*#")
    end
end

-- Execute a command on the console and wait for the shell prompt.
function VMRun:consrun(cmd, timeout)
    if self.interactive then
        return
    end
    self.vm.orch:write(cmd .. "\n")
    self.vm.orch.timeout = timeout or 5
    self.vm.orch:match("root@.*#")
end

function VMRun:scpfrom(user, key, src, dst)
    local addr, port = self.ssh_addr:match("([^:]+):(%d+)")
    exec("scp",
         "-i", key,
         "-P", port,
         "-o", "StrictHostKeyChecking=no",
         "-o", "UserKnownHostsFile=/dev/null",
         user .. "@" .. addr .. ":" .. src,
         dst
    )
end

local BhyveRun = Class({
    runargs = {},
    memory = 1024,
    name = "",
    ncpus = 1,
    orch = {},
}, VMRun._props)

function BhyveRun:_bootrom()
    if self.machine_tuple == "amd64/amd64" then
        return {
            "/usr/local/share/uefi-firmware/BHYVE_UEFI.fd",
            "edk2-bhyve"
        }
    elseif self.machine_tuple:match("^arm64/.*$") then
        return {
            "/usr/local/share/u-boot/u-boot-bhyve-arm64/u-boot.bin",
            "u-boot-bhyve-arm64"
        }
    else
        return nil
    end
end

function BhyveRun:_ctor()
    -- Can we boot the image?
    local bootrom = ""
    do
        local host = host_machine()
        if host == "amd64/amd64" then
            if self.machine_tuple ~= "amd64/amd64" and
               self.machine_tuple ~= "i386/i386" then
                errx("Host machine is %s, but machine type is %s",
                     host, self.machine_tuple)
            end
        elseif host:match("^arm64/.*") then
            if self.machine_tuple ~= "arm64/aarch64" and
               self.machine_tuple ~= "arm64/aarch64c" then
                errx("Host machine is %s, but machine type is %s",
                     host, self.machine_tuple)
            end
        else
            errx("Unsupported host machine %s", host)
        end

        local bios = self:_bootrom()
        if not bios then
            errx("Boot ROM not available for machine type %s", self.machine_tuple)
        end
        bootrom = bios[1]
        if not access(bootrom, "r") then
            errx("Boot ROM %s is not available, install %s", bootrom, bios[2])
        end
    end

    -- Build up the command-line arguments for bhyve.
    local bhyveargs = {}
    do
        local devindex = 0
        local function adddev(desc)
            local dev = sprintf("%d:0,%s", devindex, desc)
            table.append(bhyveargs, "-s", dev)
            devindex = devindex + 1
        end

        local nic
        if self.nic_driver == "virtio" then
            nic = "virtio-net"
        elseif self.nic_driver == "e1000" then
            nic = "e1000"
        else
            errx("Unsupported NIC driver %s", self.nic_driver)
        end

        table.append(bhyveargs,
            "bhyve",
            "-m", tostring(self.memory) .. "M",
            "-c", tostring(self.ncpus))
        adddev("hostbridge")
        if self.machine_tuple == "amd64/amd64" or
           self.machine_tuple == "i386/i386" then
            table.append(bhyveargs, "-H", "-P")
            table.append(bhyveargs, "-l", "com1,stdio")
            table.append(bhyveargs, "-l", "bootrom," .. bootrom)
            adddev("lpc")
        else
            table.append(bhyveargs, "-o", "console=stdio")
            table.append(bhyveargs, "-o", "bootrom=" .. bootrom)
        end

        local block
        if self.block_driver == "virtio" then
            block = "virtio-blk"
        elseif self.block_driver == "ahci" then
            block = "ahci-hd"
        elseif self.block_driver == "nvme" then
            block = "nvme"
        else
            errx("Unsupported block driver %s", self.block_driver)
        end
        adddev(block .. "," .. self.image)
        for disk in self.disk_list:gmatch("%S+") do
            adddev(block .. "," .. disk)
        end
        if not self.machine_tuple:match("^arm64/.*$") then
            -- Work around a bhyve bug/limitation on arm64.
            -- See https://reviews.freebsd.org/D45049 .
            adddev("virtio-rnd")
        end
        if self.gdb_addr then
            table.append(bhyveargs, "-G", self.gdb_addr)
        end
        if self.ssh_addr then
            -- This must be added after the first block device to work around a
            -- bhyve bug on arm64, see https://reviews.freebsd.org/D45049.
            adddev(sprintf("%s,slirp,hostfwd=tcp:%s-:22", nic, self.ssh_addr))
        end
        for tap in self.tap_list:gmatch("%S+") do
            adddev(nic .. "," .. tap)
        end
        for p9fs_share in self.p9fs_shares:gmatch("%S+") do
            local share, path = p9fs_share:match("([^:]+):(.+)")
            if not share or not path then
                errx("Invalid p9fs share description: %s", p9fs_share)
            end
            adddev(sprintf("virtio-9p,%s=%s", share, path))
        end

        table.append(bhyveargs, self.vmname)
    end

    self.name = self.vmname
    self.runargs = bhyveargs
end

function BhyveRun:boot()
    _rootexec("bhyvectl", "--destroy", "--vm=" .. self.name)
    if self.interactive then
        _rootexec(table.unpack(self.runargs))
    else
        table.prepend(self.runargs, "sudo")
        self.orch = orch_spawn(table.unpack(self.runargs))
    end
    _rootexec("bhyvectl", "--destroy", "--vm=" .. self.name)
end

local QEMURun = Class({
    args = {},
    memory = 1024,
    ncpus = 1,
    orch = {},
}, VMRun._props)

-- Return a path to the QEMU executable for this platform.
function QEMURun:_binary()
    local bins = {
        ["amd64/amd64"] = "qemu-system-x86_64",
        ["i386/i386"] = "qemu-system-i386",
        ["arm64/aarch64"] = "qemu-system-aarch64",
        ["arm64/aarch64c"] = "qemu-system-morello",
        ["arm/armv7"] = "qemu-system-arm",
        ["riscv/riscv64"] = "qemu-system-riscv64",
        ["riscv/riscv64c"] = "qemu-system-riscv64cheri",
    }
    local bin = bins[self.machine_tuple]
    if not bin then
        errx("Unsupported machine type %s", self.machine_tuple)
    end
    if bin:match("^/") then
        return bin
    else
        local path = which(bin)
        if not path then
            errx("QEMU is not in PATH, make sure it is installed")
        end
        return path
    end
end

-- Return the path to the firmware image to use in the guest, and the FreeBSD
-- port from which it is installed.
function QEMURun:_bios()
    local bioses = {
        ["arm64/aarch64"] = {
            "/usr/local/share/qemu/edk2-aarch64-code.fd", "qemu"
        },
        ["arm64/aarch64c"] = {
            (host_machine() == "arm64/aarch64c" and
             "/usr/local64/share/qemu-cheri/edk2-aarch64-code.fd" or
             "/usr/local/share/qemu/edk2-aarch64-code.fd"),
            (host_machine() == "arm64/aarch64c" and "qemu-cheri" or "qemu")
        },
        ["arm/armv7"] = {
            "/usr/local/share/u-boot/u-boot-qemu-arm/u-boot.bin", "u-boot-qemu-arm",
        },
        ["riscv/riscv64"] = {
            "/usr/local/share/opensbi/lp64/generic/firmware/fw_jump.elf", "opensbi",
        },
    }
    return bioses[self.machine_tuple]
end

function QEMURun:_cpu()
    if self.cpu then
        return self.cpu
    end
    if self.machine_tuple == "arm64/aarch64c" then
        return "morello"
    else
        return "max"
    end
end

function QEMURun:_kernel()
    local kernels = {
        ["riscv/riscv64"] = {
            "/usr/local/share/u-boot/u-boot-qemu-riscv64/u-boot.bin", "u-boot-qemu-riscv64",
        },
    }
    return kernels[self.machine_tuple]
end

function QEMURun:_machine()
    if self.machine then
        return self.machine
    end
    local machines = {
        ["arm64/aarch64c"] = "virt,gic-version=3",
        ["amd64/amd64"] = "q35",
        ["i386/i386"] = "q35",
        ["powerpc/powerpc64"] = "pseries,cap-hpt-max-page-size=16M",
    }
    return machines[self.machine_tuple] or "virt"
end

function QEMURun:_ctor(args)
    if not self.interactive then
        -- If we're interactive, we have no use for orch.
        self.orch = nil
    end

    -- Build up the QEMU command-line arguments based on our parameters.
    do
        if self.nic_driver ~= "virtio" then
            errx("Unsupported NIC driver %s", self.nic_driver)
        end
        if self.block_driver ~= "virtio" then
            errx("Unsupported block driver %s", self.block_driver)
        end
        local bios, cpu, kernel, machine = self:_bios(), self:_cpu(), self:_kernel(), self:_machine()
        local qemuargs = {}
        table.append(qemuargs,
            self:_binary(),
            "-nographic",
            "-no-reboot",
            "-smp", tostring(self.ncpus),
            "-m", tostring(self.memory) .. "M",
            "-cpu", cpu,
            "-M", machine,
            "-device", "virtio-rng-pci")
        if bios then
            if not access(bios[1], "r") then
                errx("BIOS image %s is not available, install %s", bios[1], bios[2])
            end
            table.append(qemuargs, "-bios", bios[1])
        end
        if kernel then
            if not access(kernel[1], "r") then
                errx("Kernel image %s is not available, install %s", kernel[1], kernel[2])
            end
            table.append(qemuargs, "-kernel", kernel[1])
        end
        self.disk_list = self.image .. " " .. self.disk_list
        local i = 0
        for disk in self.disk_list:gmatch("%S+") do
            local id = sprintf("image%d", i)
            table.append(qemuargs, "-device", "virtio-blk-pci,drive=" .. id)
            table.append(qemuargs,
                         "-drive",
                         sprintf("file=%s,format=raw,if=none,id=%s", disk, id))
            i = i + 1
        end
        for tap in self.tap_list:gmatch("%S+") do
            -- Requires privileges to open.
            error("TAP interfaces are not yet supported for QEMU")
            table.append(qemuargs, "-device",
                         sprintf("virtio-net-pci,netdev=net%s", tap))
            table.append(qemuargs, "-netdev",
                         sprintf("tap,id=net%s,ifname=%s", tap, tap))
        end
        for p9fs_share in self.p9fs_shares:gmatch("%S+") do
            local share, path = p9fs_share:match("([^:]+):(.+)")
            if not share or not path then
                errx("Invalid p9fs share description: %s", p9fs_share)
            end
            table.append(qemuargs, "-virtfs",
                         sprintf("local,path=%s,mount_tag=%s,security_model=none",
                                 path, share))
        end
        if self.gdb_addr then
            table.append(qemuargs, "-gdb", "tcp:" .. self.gdb_addr)
        end
        if self.ssh_addr then
            table.append(qemuargs, "-device", "virtio-net-pci,netdev=net0")
            table.append(qemuargs, "-netdev",
                         sprintf("user,id=net0,restrict=y,hostfwd=tcp:%s-:22,id=net0",
                                 self.ssh_addr))
        end
        self.args = qemuargs
    end
end

function QEMURun:boot()
    if self.interactive then
        exec(table.unpack(self.args))
    else
        self.orch = orch_spawn(table.unpack(self.args))
    end
end

function VMRun:_ctor(args)
    local hypervisor = args.hypervisor
    args.hypervisor = nil
    if hypervisor == "bhyve" then
        self.vm = BhyveRun(args)
    elseif hypervisor == "qemu" then
        self.vm = QEMURun(args)
    else
        errx("Unsupported hypervisor %s", self.vm.hypervisor)
    end
end

-------------------------------- Task stuff --------------------------

local TaskParameter = Class({
    parent = {},
    source = "",
    valid = function () return true end,
    _value = "",
}, {
    -- Textual description of the parameter.
    description = "string",
    -- Default value for the parameter.
    default = "*",
    -- Name of the parameter in the enclosing task.  Should not be set in the
    -- task definition.
    name = "string",
    -- Does this need to be set for the task to run?
    required = "boolean",
    -- Type of the parameter, can be inferred from the default.
    type = "string",
    -- A predicate which says whether the value is valid.  Can be a function
    -- which takes the value as input and returns a boolean, or a table of
    -- permitted values.
    valid = function (v) return type(v) == "function" or type(v) == "table" end,
})

function TaskParameter:_ctor(args)
    local default = args.default
    if default ~= nil then
        if type(default) == "function" then
            default = default()
        end
        if args.type == nil then
            self.type = type(default)
        end
        if default ~= nil then
            self:bind(default, "default")
        end
    end
end

-- Set the value for a task parameter.  This can come from multiple sources, so
-- let the caller record itself to make it easier to trace the origin of a
-- value.
function TaskParameter:bind(v, source)
    -- Is the value valid according to the parameter definition?
    do
        local valid = false
        if type(self.valid) == "function" then
            valid = self.valid(v)
            assert(type(valid) == "boolean")
        else
            for _, candidate in ipairs(self.valid) do
                if v == candidate then
                    valid = true
                    break
                end
            end
        end
        if not valid then
            errx("Invalid value for parameter '%s'", self.name)
        end
    end

    -- Convert string values of type "boolean" to actual booleans so that
    -- truth tests work as expected.
    do
        if self.type == "boolean" and type(v) ~= "boolean" then
            if v == "true" then
                v = true
            elseif v == "false" then
                v = false
            else
                errx("Invalid boolean value for parameter '%s'", self.name)
            end
        elseif self.type == "number" then
            v = tonumber(v)
            if v == nil then
                errx("Invalid number value for parameter '%s'", self.name)
            end
        end
    end

    self.source = source
    self._value = v
end

function TaskParameter:bound()
    return self.source ~= ""
end

function TaskParameter:value()
    if not self:bound() then
        return nil
    end
    return self._value
end

-- A task encapsulates some code that a user wants to run as part of a workflow.
-- This could be something like cloning a repository, running a build command,
-- booting a VM, etc..
--
-- A task's parameters are user-configurable and can be interrogated by the
-- framework.
--
-- Each task has to implement a default run() action, which Does The Thing.
-- However, it may also support auxilliary actions.  For example the
-- FreeBSDVMBoot task's default action would be to boot the VM, but one could
-- also use ssh action to ssh into the VM.
local Task = Class({
    _done = false,
    _out = {},
    _run = function () end,

    actions = {},
    dependencies = {},
    inputs = {},
    outputs = {},
    parameters = {},

    starttime = 0,
    endtime = 0,
}, {
    _workdir = "string",

    -- Parent task name.
    [1] = "string",

    -- A list of additional commands that can be run within the task workdir.
    -- Generally, tasks will just implement run() and leave it at that, but in
    -- some cases it might be useful to run secondary tasks.
    actions = "table",
    -- List of executables that need to be in the PATH.
    dependencies = "table",
    -- Textual descriptions of what the task does.
    description = "string",
    long_description = "string",
    -- List of tasks that need to run before this one.
    inputs = "table",
    -- Unique name for this task.
    name = "string",
    -- Descriptions of output values from the task.
    outputs = "table",
    -- Parameter definitions.
    parameters = "table",
    -- Run the task.  A single "self" parameter is provided, a table with
    -- parameter values and objects bound to the keys in the task definition.
    run = "function",
})

-- Global set of tasks, keyed by task name.
local tasks = {}

function Task:_ctor(props)
    -- Register the task in the global database.
    if not props.name then
        errx("Task definition is missing a name")
    elseif tasks[props.name] then
        errx("Task '%s' has multiple definitions", props.name)
    end
    tasks[props.name] = self

    local parent
    if self[1] then
        parent = tasks[self[1]]
        if not parent then
            errx("Task '%s' parent '%s' does not exist", props.name, self[1])
        end
    end

    -- Swizzle the run() implementation.  _run is the function that the task
    -- implements (called "run" in the task definition), and Task:run() is a
    -- wrapper which sets up context.  If the task inherits from another task
    -- and defines its own "run" implementation, it can call the parent's
    -- implementation using "super".
    do
        local run, super
        if not props.run then
            if parent then
                run = parent._run
                super = parent.super
            else
                errx("Task '%s' has no run() implementation", props.name)
            end
        else
            run = props.run
            if parent then
                super = parent._run
            end
        end
        self._run = run
        self.run = Task.run
        self.super = super
    end

    -- Normalize input definitions.  They can be of the form
    --   inputname = "task"
    -- or
    --   inputname = {"task", param1 = value1, ... }
    -- Convert the first form to the second.
    do
        for k, v in pairs(self.inputs) do
            if type(v) == "string" then
                self.inputs[k] = {v}
            end
        end
    end

    -- Inherit input, parameter and output descriptions from the parent task.
    -- Also pick up dependencies and auxilliary actions.
    if parent then
        for k, v in pairs(parent.inputs) do
            if self.inputs[k] then
                local input = self.inputs[k]
                if input[1] == v[1] then
                    self.inputs[k] = table.merge(v, input)
                end
            else
                self.inputs[k] = v
            end
        end
        for k, v in pairs(parent.parameters) do
            self.parameters[k] = table.merge(v, self.parameters[k])
        end
        for k, v in pairs(parent.outputs) do
            if not self.outputs[k] then
                self.outputs[k] = v
            end
        end

        self.dependencies = table.merge(self.dependencies, parent.dependencies)
        self.actions = table.merge(self.actions, parent.actions)
    end

    -- Make sure that the task's namespace is clean.  All parameter, input and
    -- output names must be unique with respect to each other.  Some names are
    -- reserved.
    do
        local function check_overlap(me, k1, k2)
            local t = table.intersection(me[k1], me[k2])
            if #t > 0 then
                errx("Task '%s' has %s and %s with the same name: %s",
                     props.name, k1, k2, table.concat(t, ", "))
            end
        end
        check_overlap(self, "parameters", "inputs")
        check_overlap(self, "parameters", "outputs")
        check_overlap(self, "inputs", "outputs")
        for k, _ in pairs(table.union(self.parameters, self.inputs, self.outputs)) do
            if k == "run" then
                errx("Task '%s' is using a reserved name: %s", props.name, k)
            elseif k:match("^_") then
                -- Keep this space for internal use.
                errx("Task '%s' value name starts with an underscore: %s", props.name, k)
            end
        end
    end

    setmetatable(self, {
        __call = function (task, ...)
            if select("#", ...) ~= 1 then
                errx("Task constructor takes a single table argument")
            end
            local t = select(1, ...)
            for k, _ in pairs(t) do
                local p = self.parameters[k]
                if not p then
                    errx("Task '%s' has no parameter '%s'", self.name, k)
                end
            end
            return task
        end
    })
end

-- Set up the execution context for a task.  In short, we create a table which:
-- * has the task parameter values bound to keys,
-- * has input tasks bound to keys,
-- * can be used to set output values, consumed by the calling task.
-- Also create and cd into the working directory for that particular task.
function Task:run(ctx)
    local prefix = ansicolor("TASK", "yellow") .. ": " .. self.name
    if self._done then
        print(prefix .. " already done")
        return self._out
    end

    local params = {}
    for k, v in pairs(self.parameters) do
        if self[k] then
            -- A hack that lets the parent task set parameters directly.  This
            -- is used by openzfs-test-suite-vm-image to set sysdir, for
            -- instance.
            --
            -- We should consider a convention for such parameters, maybe their
            -- names start with an underscore, some kind of signal that the
            -- user shouldn't be setting them directly.
            params[k] = self[k]
        else
            params[k] = v:value()
        end
    end
    for k, v in pairs(self.inputs) do
        assert(params[k] == nil)
        params[k] = v
    end
    params.run = function (me) return me end
    params.super = self.super

    -- Add a metatable to catch accesses of keys that don't exist.
    local mt = {
        __index = function (_, k)
            if not self.parameters[k] then
                errx("No key '%s' in task context", k)
            end
            return nil
        end,
        __newindex = function (t, k, v)
            if self.outputs[k] == nil then
                errx("Task '%s' has no output '%s'", self.name, k)
            end
            rawset(t, k, v)
        end,
    }
    setmetatable(params, mt)

    local oldcwd = pwd()
    mkdircd(ctx.workdir .. "/" .. self.name)

    -- If we were asked to invoke an auxilliary action, do that instead
    -- of running the main action.
    if ctx.action then
        local action = self.actions[ctx.action]
        if not action then
            errx("Task '%s' has no action '%s'", self.name, ctx.action)
        end
        action(params)
    else
        print(prefix .. " running")
        self.starttime = os.time()
        self._run(params, ctx)
        self.endtime = os.time()
        for k, _ in pairs(self.outputs or {}) do
            if params[k] == nil then
                errx("Task '%s' did not set output '%s'", self.name, k)
            end
            self[k] = params[k]
        end
        self._done = true
        self._out = params

        print(sprintf("%s done (%d seconds)", prefix, os.difftime(self.endtime, self.starttime)))
    end

    cd(oldcwd)
    return params
end

local TaskSchedule = Class({
    -- A table of tasks that will be executed as part of executing the target
    -- task.  This is keyed by task name; in particular, a given task can be
    -- scheduled at most once.
    tasks = {},
}, {
    -- A table of key-value pairs that get passed to all tasks.
    ctx = "table",
    -- An array of task parameters set on the command line.  Each entry is of
    -- the form '<task name>=<value>'.
    parameters = "table",
    -- The name of the task to run.
    target = "string",
})

function TaskSchedule:_ctor(args)
    if not tasks[args.target] then
        errx("Unknown target task '%s'", args.target)
    end

    -- Build the list of tasks that we will run, check for dependencies.
    local function add_inputs(t)
        for _, input in pairs(t.inputs) do
            local name = input[1]
            local task = tasks[name]
            if not task then
                errx("Task '%s' has unknown input '%s'", t.name, name)
            end
            add_inputs(tasks[name])
        end
        for _, dep in ipairs(t.dependencies) do
            if not which(dep) then
                errx("Task '%s' requires '%s' to be in PATH", t.name, dep)
            end
        end

        if not self.tasks[t.name] then
            for k, v in pairs(t.parameters) do
                v.name = k
                t.parameters[k] = TaskParameter(v)
            end
            self.tasks[t.name] = t
        end
    end
    add_inputs(tasks[self.target])

    -- Bind parameter values from higher-level tasks.
    for _, task in pairs(self.tasks) do
        for iname, input in pairs(task.inputs) do
            local name = input[1]
            local itask = self.tasks[name]
            task.inputs[iname] = itask
            for k, v in pairs(input) do
                if k ~= 1 then
                    local param = itask.parameters[k]
                    if not param then
                        errx("Task '%s' has no parameter '%s'", itask.name, k)
                    end
                    if param.source:match("specified by ") then
                        -- More than one task has set this parameter.  We don't
                        -- know which one should win.
                        errx("Task '%s' has multiple sources for parameter '%s'",
                             task.name, k)
                    end
                    itask.parameters[k]:bind(v, "specified by " .. task.name)
                end
            end
        end
    end

    -- Bind parameter values from the command line.
    for _, s in ipairs(args.parameters) do
        local t, p, v = s:match("([^=:]+):([^=]+)=(.*)")
        if not t then
            errx("Invalid parameter '%s', should be <task>:<param>=<value>", s)
        end
        local task = self.tasks[t]
        if not task then
            errx("Unknown task '%s' in '%s'", t, s)
        end
        local param = task.parameters[p]
        if not param then
            errx("Task '%s' has no parameter '%s'", task.name, p)
        end
        param:bind(v, "command line")
    end
end

-- Run the target task.  In general the "run" implementation of the target
-- will invoke that of all subordinate tasks.
function TaskSchedule:run()
    -- Are any required parameters unbound?
    do
        for _, task in pairs(self.tasks) do
            for _, param in pairs(task.parameters) do
                if param.required and not param:bound() then
                    errx("Required task parameter '%s:%s' is not bound",
                         task.name, param.name)
                end
            end
        end
    end

    do
        local task = self.tasks[self.target]
        mkdircd(self.ctx.workdir)
        task:run(self.ctx)
    end
end

function TaskSchedule:show()
    local tasklist = table.keys(self.tasks)
    table.sort(tasklist)
    for _, tname in ipairs(tasklist) do
        print(tname)
        local params = table.keys(self.tasks[tname].parameters)
        table.sort(params)
        for _, pname in ipairs(params) do
            local p = self.tasks[tname].parameters[pname]
            if p.required and not p:bound() then
                printf("  %s=%s", pname, ansicolor("???", "red"))
            else
                local source = not p:bound() and "unset" or p.source
                printf("  %s=%s (%s)", pname, tostring(p:value()), source)
            end
            printf("    %s", p.description)
        end
    end
end

-------------------------------- Task Implementations ----------------

Task{
    name = "git-checkout",
    description = "Check out a Git repository",
    dependencies = {"git"},
    parameters = GitRepository.task_parameters(),
    outputs = {
        path = "string",
    },

    run = function(self)
        -- Are we dealing with an external repository?
        do
            -- If the URL is a path, treat it as an external repository and
            -- don't touch it.
            if self.url:match("^/") then
                local path = self.url
                local sb, errstr = _stat.stat(path)
                if not sb then
                    errx("Failed to stat %s: %s", path, errstr)
                end
                if not _stat.S_ISDIR(sb.mode) then
                    errx("Path %s is not a directory", path)
                end
                if self.branch then
                    local branch = GitRepository.checked_out_branch(path)
                    if branch ~= self.branch then
                        errx("Repository %s is on branch %s, not %s",
                             path, branch, self.branch)
                    end
                end
                self.path = self.url
                return
            end
        end

        local path = pwd() .. "/src"
        GitRepository.clone_or_update(path, self)
        self.path = path
    end
}

Task{"git-checkout",
    name = "freebsd-src",
    description = "Check out the FreeBSD source tree",
    parameters = {
        branch = {
            default = "main"
        },
        url = {
            default = "anongit@git.freebsd.org:src.git"
        },
    },
    outputs = {
        -- The value of the src tree's __FreeBSD_version.
        FreeBSD_version = "string",
    },

    run = function (self, ctx)
        self:super(ctx)

        -- Get the __FreeBSD_version value from sys/param.h.
        do
            local f = io.open_checked(self.path .. "/sys/sys/param.h", "r")
            local found = false
            for line in f:lines() do
                local version = line:match("#define%s+__FreeBSD_version%s+(%d+)")
                if version then
                    self.FreeBSD_version = version
                    found = true
                    break
                end
            end
            if not found then
                errx("Failed to find __FreeBSD_version in %s", self.path)
            end
        end
    end,
}

Task{"git-checkout",
    name = "freebsd-pkg-src",
    description = "Check out the FreeBSD pkg source tree",
    parameters = {
        branch = {
            default = "main"
        },
        url = {
            default = "https://github.com/freebsd/pkg"
        },
    }
}

Task{
    name = "freebsd-pkg-build",
    description = "Build pkg and run tests",
    dependencies = {"kyua"},
    inputs = {
        src = "freebsd-pkg-src",
    },
    parameters = {
        tests = {
            description = "Run tests after building?",
            default = true,
        },
        asan = {
            description = "Build with AddressSanitizer?",
            default = false,
        },
        ubsan = {
            description = "Build with UndefinedBehaviorSanitizer?",
            default = false,
        },
    },
    outputs = {
        -- A path to the kyua database containing test run results.
        test_results = "string",
    },

    run = function(self, ctx)
        self.src = self.src:run(ctx)

        local configure_args = {"./configure"}
        if self.asan then
            table.insert(configure_args, "--with-asan")
        end
        if self.ubsan then
            table.insert(configure_args, "--with-ubsan")
        end

        local cwd = pwd()
        cd(self.src.path)
        exec(table.unpack(configure_args))
        exec("make", "all", "-j", ctx.maxjobs)
        if self.tests then
            local dbpath = cwd .. "/results.db"
            unlink(dbpath)
            exec("kyua", "test", "-k", "tests/Kyuafile", "-r", dbpath)
            self.test_results = dbpath
        else
            self.test_results = "/dev/null"
        end
    end
}

Task{
    name = "freebsd-src-build",
    description = "Run one or more 'make' commands in a FreeBSD src checkout",
    parameters = {
        clean = {
            description = "Clean the build directory before building",
            default = false,
        },
        kernel_config = {
            description = "The kernel configuration file to use for buildkernel",
            type = "string",
            default = function ()
                return host_machine() == "arm64/aarch64c" and "GENERIC-MORELLO" or nil
            end,
        },
        kernel_modules = {
            description = "A list of kernel modules to build, all are built by default",
            type = "string",
        },
        machine = {
            description = "The target platform , e.g., amd64 or arm64/aarch64",
            default = host_machine(),
            type = "string",
        },
        make_arguments = {
            description = "Arguments to pass to make(1)",
            type = "string",
        },
        make_targets = {
            description = "The make(1) target(s) to build, e.g., buildworld",
            default = "",
        },
        toolchain = {
            description = "The toolchain to use for the build",
            type = "string",
        },
    },
    inputs = {
        src = "freebsd-src",
    },
    outputs = {
        -- A slash-separated pair of strings naming the target architecture.
        machine_tuple = "string",
        -- The mtree file describing any installed files.
        metalog = "table", -- MTree object
        -- A path to a directory containing compiled outputs.
        objdir = "string",
        -- A path to a staged rootless installation of the build.
        stagedir = "string",
    },

    run = function(self, ctx)
        self.src = self.src:run(ctx)

        -- See if the user specified a valid target platform.
        local machine, machine_arch
        do
            machine, machine_arch = self.machine:match("^(%w+)/(%w+)$")
            if not machine then
                machine = self.machine
                machine_arch = machine
            end

            local found = false
            local output = runcmd("make", "-C", self.src.path, "targets")
            for target in output:gmatch("(%w+/%w+)%s*\n") do
                if target == machine .. "/" .. machine_arch then
                    found = true
                    break
                end
            end
            if not found then
                errx("Machine target %s/%s is not supported", machine, machine_arch)
            end
            self.machine_tuple = machine .. "/" .. machine_arch
        end

        -- Set up the object directory for the build.  It may be useful to use
        -- the default objdir instead, but that makes cleaning more
        -- complicated.
        self.objdir = sprintf("%s/obj.%s.%s", pwd(), machine, machine_arch)
        mkdir(self.objdir)

        -- Create a staging directory for install targets, one per machine
        -- target.
        self.stagedir = sprintf("%s/stage.%s.%s", pwd(), machine, machine_arch)
        mkdir(self.stagedir)

        -- Set up the build arguments and environment, then run make(1).  We
        -- might have no make(1) targets to run, in which case there's nothing
        -- to do.
        do
            for make_target in self.make_targets:gmatch("%S+") do
                -- We create one metalog per target and combine them later.
                local metalog = sprintf("%s/METALOG.%s.mtree", self.stagedir, make_target)
                exec("truncate", "-s", "0", metalog)

                -- Build up command-line arguments...
                local args = {
                    "-ss",
                    "-j", ctx.maxjobs,
                    "-DNO_ROOT",
                    "DESTDIR=" .. self.stagedir,
                    "METALOG=" .. metalog,
                    "TARGET=" .. machine,
                    self.clean and "WITH_CLEAN=" or "WITHOUT_CLEAN=",
                }
                table.insert(args, machine_arch and "TARGET_ARCH=" .. machine_arch or nil)
                table.insert(args, self.kernel_config and "KERNCONF=" .. self.kernel_config or nil)
                table.insert(args, self.kernel_modules and "MODULES_OVERRIDE=" .. self.kernel_modules or nil)
                table.insert(args, self.toolchain and "CROSS_TOOLCHAIN=" .. self.toolchain or nil)
                if self.make_arguments then
                    for arg in self.make_arguments:gmatch("%S+") do
                        table.insert(args, arg)
                    end
                end
                -- ... and add the make(1) target...
                table.insert(args, make_target)
                -- ... and finally customize the current environment.
                local env = environ(
                    "MAKEOBJDIRPREFIX=" .. self.objdir,
                    "SRCCONF=/dev/null",
                    "__MAKE_CONF=/dev/null"
                )
                table.insert(args, env)
                exec("make", "-C", self.src.path, table.unpack(args))
            end

            local metalogs = glob.glob(sprintf("%s/METALOG.*.mtree", self.stagedir))
            local installworld_metalog = sprintf("%s/METALOG.installworld.mtree", self.stagedir)
            for i, metalog in ipairs(metalogs) do
                -- The installworld metalog has to come first, if it's there.
                if metalog == installworld_metalog then
                    table.remove(metalogs, i)
                    table.insert(metalogs, 1, installworld_metalog)
                    break
                end
            end

            -- Provide the output mtree for any installation targets.
            self.metalog = MTree{
                -- This is not quite right since the user might conceivably
                -- override our name, but hopefully they have no good reason to do
                -- that.
                src = metalogs,
                root = self.stagedir,
                defaults = {
                    uname = "root",
                    gname = "wheel",
                },
            }
        end
    end
}

Task{"git-checkout",
    name = "syzkaller-src",
    description = "Check out the syzkaller source tree",
    parameters = {
        branch = {
            default = "master"
        },
        url = {
            default = "https://github.com/google/syzkaller"
        },
    },
}

Task{
    name = "syzkaller-build",
    description = "Build syzkaller",
    dependencies = {"bash", "gmake", "go"},
    inputs = {
        src = "syzkaller-src",
    },
    parameters = {
        regen_syscalls = {
            description = "Regenerate syscall descriptions from system headers?",
            default = false,
        },
        test = {
            description = "Run tests after building?",
            default = false,
        },
    },
    outputs = {
        -- A path to a directory containing compiled executables.
        bindir = "string",
    },

    run = function(self, ctx)
        self.src = self.src:run(ctx)

        -- Build the syzkaller executables.
        do
            local env = environ("GOMAXPROCS=" .. ctx.maxjobs)

            -- The syzkaller build consumes huge amounts of memory, limit
            -- parallelism further to minimize sadness.  Despite the name this
            -- just limits the number of parallel compiler instances, not the
            -- number of cores used.
            exec("gmake", "-C", self.src.path, "NCORES=1", env)
            if self.test then
                exec("gmake", "-C", self.src.path, "test", env)
            end
        end

        local bindir = pwd() .. "/bin"
        exec("rm", "-rf", bindir)
        exec("cp", "-R", self.src.path .. "/bin", bindir)
        self.bindir = bindir
    end
}

Task{
    name = "syzkaller-freebsd-fuzz",
    description = "Run syzkaller against a FreeBSD target",
    long_description = [[
This task builds a VM image containing FreeBSD, builds syzkaller, and fuzzes
the FreeBSD image.  Once everything is built, this is mostly a matter of running
syz-manager, which knows how to boot VMs, install the fuzzer, detect crashes, and
so on.

The task will run syz-manager in the foreground.  syz-manager also provides a
web dashboard which gives info about crashes and fuzzer state.  The
"dashboard_addr" parameter controls where the dashboard listens.

The task lets you choose between bhyve and QEMU as the hypervisor for fuzzing
VMs.  QEMU is simpler to configure, doesn't require root privileges, and enables
cross-platform fuzzing (e.g., riscv on amd64), but is of course slower.  The
overhead of emulation is exacerbated by the use of sanitizers in the guest.

bhyve is more efficient but requires privileges.  Because it lacks snapshot
support, it relies on the use of ZFS clones to snapshot VM images; the ZFS
filesystem used for this purpose must be created in advance.

When troubleshooting, set the "debug" parameter to true to run syz-manager in
debug mode.
]],
    -- Need a way to check the pkg database.
    --dependencies = {"libslirp"},

    inputs = {
        syzkaller_src = "syzkaller-src",
        syzkaller_build = "syzkaller-build",
        freebsd_src = "freebsd-src",
        freebsd_build = {"freebsd-src-build",
            kernel_config = "SYZKALLER",
        },
        vm_image = "freebsd-src-syzkaller-vm-image",
    },
    parameters = {
        dashboard_addr = {
            description = "The address on which the dashboard should listen for HTTP",
            default = "0.0.0.0:8080",
        },
        debug = {
            description = "Run syz-manager in debug mode?",
            default = false,
        },
        hypervisor = {
            description = "The hypervisor to use for fuzzing",
            default = "qemu",
            valid = {"bhyve", "qemu"},
        },
        parent_kernel_config = {
            description = "The parent kernel configuration to use",
            default = "GENERIC",
        },
        target_architecture = {
            description = "The target architecture for the VM",
            default = "amd64",
            valid = {"amd64", "arm64", "riscv"},
        },
        verbosity = {
            description = "Verbosity level to pass to syz-manager",
            default = 0,
        },
        vm_count = {
            description = "The number of VMs to run",
            default = 1,
        },
        vm_ncpu = {
            description = "The number of CPUs to allocate to each VM",
            default = 2,
        },
        vm_memory = {
            description = "The amount of memory to allocate to each VM, in MB",
            default = 2048,
        },
        zfs_dataset = {
            description = "The mounted ZFS dataset to use, required by bhyve",
            type = "string",
        },
    },

    run = function(self, ctx)
        -- Do some parameter validation.
        do
            if self.vm_ncpu * self.vm_count > ctx.maxjobs then
                errx("Insufficient parallelism to run %d VMs with %d CPUs each",
                     self.vm_count, self.vm_ncpu)
            end

            if self.hypervisor == "bhyve" then
                if not self.zfs_dataset then
                    errx("bhyve requires a ZFS dataset to store VM images, " ..
                         "set syzkaller-freebsd-fuzz:zfs_dataset")
                end
                local mountpoint = zfs_get(self.zfs_dataset, "mountpoint")
                if mountpoint == "none" then
                    errx("ZFS dataset %s is not mounted", self.zfs_dataset)
                end

                -- bhyve doesn't perform emulation, so the target arch must
                -- match the host.
                local valid_hosts = {
                    amd64 = {"amd64/amd64"},
                    arm64 = {"arm64/aarch64"},
                    riscv = {"riscv/riscv64"},
                }
                local found = false
                for _, v in ipairs(valid_hosts[self.target_architecture]) do
                    if v == host_machine() then
                        found = true
                        break
                    end
                end
                if not found then
                    errx("bhyve cannot boot %s kernels on %s",
                         self.target_architecture, host_machine())
                end

                -- The bhyve backend wants a memory unit.
                self.vm_memory = "\"" .. self.vm_memory .. "M\""
            end
        end

        self.syzkaller_src = self.syzkaller_src:run(ctx)
        self.syzkaller_build = self.syzkaller_build:run(ctx)

        -- Set up the kernel configuration file needed to build a kernel with
        -- code coverage tracking.
        -- XXX-MJ this should be done in the vm_image task, but we need to
        -- be able to set the build target machine from target_architecture.
        do
            self.freebsd_src = self.freebsd_src:run(ctx)
            local confpath = sprintf("%s/sys/%s/conf/SYZKALLER",
                                     self.freebsd_src.path,
                                     self.target_architecture)
            writefile(confpath, ([[
include %s
ident SYZKALLER

options 	COVERAGE
options 	KCOV
]]):format(self.parent_kernel_config))
        end

        -- Build the VM image that we'll be fuzzing.
        self.vm_image = self.vm_image:run(ctx)

        -- Do some setup required for bhyve.
        local hypervisor_args, image_path = "", ""
        do
            if self.hypervisor ~= "bhyve" then
                -- -enable-kvm is hard-coded in the QEMU parameters for FreeBSD
                -- targets, so we have to do this fragile thing to remove it.
                hypervisor_args = "\"qemu_args\": \"\","
                image_path = self.vm_image.image
                goto skip_bhyve_setup
            end

            hypervisor_args = "\"dataset\": \"" .. self.zfs_dataset .. "\","

            local mountpoint = zfs_get(self.zfs_dataset, "mountpoint")
            image_path = mountpoint .. "/syzkaller.img"
            rootexec("cp", "-f", self.vm_image.image, image_path)

            ::skip_bhyve_setup::
        end

        -- Build up the syz-manager configuration file and start running.
        do
            local machine, machine_arch = self.freebsd_build.machine_tuple:match("^(%w+)/(%w+)$")
            local syzconf = pwd() .. "/syz-manager.conf"
            local workdir = pwd() .. "/workdir"
            mkdir(workdir)
            writefile(syzconf, substitute([[
{
    "target": "freebsd/$arch",
    "workdir": "$workdir",
    "http": "$addr",
    "type": "$hypervisor",
    "syzkaller": "$syzkaller_path",
    "image": "$image_path",
    "kernel_src": "$kernel_src",
    "kernel_obj": "$kernel_obj",
    "ssh_user": "root",
    "sshkey": "$sshkey",
    "procs": 2,
    "vm": {
        $hypervisor_args
        "cpu": $vm_ncpu,
        "mem": $vm_memory,
        "count": $vm_count
    }
}
]], {
    addr = self.dashboard_addr,
    arch = self.target_architecture,
    hypervisor = self.hypervisor,
    hypervisor_args = hypervisor_args,
    image_path = image_path,
    kernel_src = self.freebsd_src.path,
    kernel_obj = sprintf("%s/%s/%s.%s/sys/SYZKALLER",
                         self.freebsd_build.objdir, self.freebsd_src.path,
                         machine, machine_arch),
    sshkey = self.vm_image.ssh_key_directory .. "/id_ed25519_root",
    syzkaller_path = self.syzkaller_src.path,
    workdir = workdir,
    vm_count = self.vm_count,
    vm_memory = self.vm_memory,
    vm_ncpu = self.vm_ncpu,
}))

            local syz_manager_args = {
                self.syzkaller_build.bindir .. "/syz-manager",
                "-config", syzconf,
            }
            if self.debug then
                table.insert(syz_manager_args, "-debug")
            end
            table.insert(syz_manager_args, "-vv")
            table.insert(syz_manager_args, self.verbosity)

            if self.hypervisor == "qemu" then
                exec(table.unpack(syz_manager_args))
            else
                rootexec(table.unpack(syz_manager_args))
            end
        end
    end,
}

Task{
    name = "freebsd-src-vm-image",
    description = "Build a VM image containing FreeBSD",
    inputs = {
        src = "freebsd-src",
        build = {"freebsd-src-build",
            make_targets = "buildworld buildkernel installworld installkernel distribution",
        },
    },
    outputs = {
        image = "string",
        ssh_key_directory = "string",
    },
    parameters = {
        filesystem = {
            description = "The filesystem to use for the VM",
            default = "ufs",
            valid = {"ufs", "zfs"},
        },
        hostname = {
            description = "The hostname for the VM",
            default = "freebsd",
        },
        image_size = {
            description = "The size of the VM image in bytes",
            default = "10g",
        },
        loader_kld_list = {
            description = "A list of kernel modules to load upon boot via loader.conf",
            default = "",
        },
        loader_tunables = {
            description = "A set of loader tunables to set prior to boot",
            default = "",
        },
        overlay = {
            description = "A directory to overlay on the VM image",
            type = "string"
        },
        packages = {
            description = "A list of packages to install on the VM upon first boot",
            default = "",
        },
        rc_kld_list = {
            description = "A list of kernel modules to load upon boot via rc.conf",
            default = "",
        },
        ssh_users = {
            description = "A list of users to grant SSH access to the VM",
            valid = {"", "root"},  -- No support for adding users right now.
            default = "",
        },
        sudo_users = {
            description = "A list of users to grant sudo privileges, useful for tests",
            default = "",
        },
        swap_size = {
            description = "The size of the swap partition",
            default = "2G",
        },
    },

    run = function(self, ctx)
        self.build = self.build:run(ctx)

        local mtree = self.build.metalog
        local stagedir = self.build.stagedir

        -- Create ssh keys for the VM.
        do
            local keydir = pwd() .. "/ssh-keys"
            mkdir("ssh-keys")
            for user in self.ssh_users:gmatch("%S+") do
                local keyfile = keydir .. "/id_ed25519_" .. user
                unlink(keyfile)
                exec("ssh-keygen", "-t", "ed25519", "-N", "", "-f", keyfile)

                local dstdir
                if user == "root" then
                    dstdir = "./root/.ssh"
                else
                    dstdir = "./home/" .. user .. "/.ssh"
                end
                local dst = dstdir .. "/authorized_keys"
                mkdir(stagedir .. "/" .. dstdir, octal("0700"))
                exec("cp", "-f", keyfile .. ".pub", stagedir .. "/" .. dst)
                mtree:add(dstdir)
                mtree:add(dst)

                if user == "root" then
                    local f = io.open_checked(stagedir .. "/etc/ssh/sshd_config", "a")
                    f:write("PermitRootLogin without-password\n")
                    f:close()
                end
            end
            self.ssh_key_directory = keydir
        end

        -- Populate some configuration files to our liking, and create
        -- /firstboot.
        do
            local function conffile(path, ...)
                assert(path:match("^/"))
                local contents = ""
                for _, line in ipairs({...}) do
                    if line ~= "" then
                        contents = contents .. line .. "\n"
                    end
                end
                writefile(stagedir .. path, contents)
                mtree:add("." .. path)
            end

            local loader_klds = {}
            for kld in self.loader_kld_list:gmatch("%S+") do
                table.insert(loader_klds, kld .. "_load=\"YES\"")
            end
            local loader_tunables = {}
            for tunable in self.loader_tunables:gmatch("%S+") do
                table.insert(loader_tunables, tunable)
            end
            local rc_klds = {}
            for kld in self.rc_kld_list:gmatch("%S+") do
                table.insert(rc_klds, "kld_list=\"${kld_list} " .. kld .. "\"")
            end

            local loader_conf_entries = table.append(loader_klds, table.unpack(loader_tunables))
            conffile("/boot/loader.conf",
                "autoboot_delay=1",
                "console=comconsole",
                "kern.geom.label.disk_ident.enable=0", -- Work around swap partition issues.
                "virtio_p9fs_load=YES",
                self.filesystem == "zfs" and "zfs_load=YES" or "",
                table.unpack(loader_conf_entries))
            conffile("/etc/rc.conf",
                "hostname=" .. self.hostname,
                "ifconfig_vtnet0=SYNCDHCP", -- XXX-MJ interface name is hard-coded
                "ifconfig_em0=SYNCDHCP",    -- XXX-MJ interface name is hard-coded
                "defaultroute_delay=2",
                "growfs_enable=YES",
                "sshd_enable=YES",
                "sshd_rsa_enable=NO",       -- Obsolete and slow to generate.
                self.filesystem == "zfs" and "zfs_enable=YES" or "",
                self.filesystem == "zfs" and "zpool_reguid=zroot" or "",
                table.unpack(rc_klds))
            conffile("/etc/fstab",
                self.filesystem == "ufs" and "/dev/gpt/rootfs / ufs rw 1 1" or "",
                "none /dev/fd fdescfs rw 0 0",
                "/dev/gpt/swap none swap sw 0 0")
            conffile("/firstboot")
        end

        -- Add sudoers files.
        do
            for user in self.sudo_users:gmatch("%S+") do
                local file = "usr/local/etc/sudoers.d/" .. user
                local sudoers = stagedir .. "/" .. file
                writefile(sudoers, user .. " ALL=(ALL) NOPASSWD: ALL")
                mtree:add("./" .. file)
            end
        end

        -- Create a local pkg repository.  The idea here is to fetch all of the
        -- requested packages into /root/pkg in the image, create a local
        -- repository out of them, and then ensure that those packages get
        -- installed automatically upon first boot.
        do
            local pkgabi = sprintf("FreeBSD:%s:%s",
                                   self.src.FreeBSD_version:sub(1, 2),
                                   self.build.machine_tuple:match("^%w+/(%w+)"))

            local repodir = stagedir .. "/tmp/pkg"
            mkdir(repodir)
            writefile(repodir .. "/repo.conf", substitute([[
FreeBSD: {
    url: "pkg+http://pkg.FreeBSD.org/$ABI/latest",
    mirror_type: "srv",
    signature_type: "fingerprints",
    fingerprints: "/usr/share/keys/pkg",
    enabled: yes
}
]], {
    ABI = pkgabi,
}))

            local pkgs = {}
            for pkg in self.packages:gmatch("%S+") do
                table.insert(pkgs, pkg)
            end
            if #pkgs == 0 then
                goto pkgdone
            end

            -- Return the argv of a pkg command.
            local function _pkgcmd(...)
                local pkgcmd_prefix = {
                    "pkg",
                    "-o", "ASSUME_ALWAYS_YES=true",
                    "-o", "INSTALL_AS_USER=yes",
                    "-o", "ABI=" .. pkgabi,
                    "-o", "PKG_CACHEDIR=./var/cache/pkg",
                    "-o", "REPOS_DIR=./tmp/pkg",
                    "-o", "PKG_DBDIR=./var/db/pkg",
                    "-o", "OSVERSION=" .. self.src.FreeBSD_version,
                }
                local t = table.deepcopy(pkgcmd_prefix)
                for _, arg in ipairs({...}) do
                    table.insert(t, arg)
                end
                return t
            end

            -- Run a pkg command in the staging directory.
            local function pkgcmd(...)
                local oldcwd = cd(stagedir)
                exec(table.unpack(_pkgcmd(...)))
                cd(oldcwd)
            end

            local bootstrapdir = "root/bootstrap/" .. pkgabi
            local pkgdir = "root/pkg/" .. pkgabi

            pkgcmd("update")
            pkgcmd("fetch", "--dependencies", "-o", "./" .. bootstrapdir, "pkg")
            pkgcmd("fetch", "--dependencies", "-o", "./" .. pkgdir, table.unpack(pkgs))
            pkgcmd("repo", "./" .. pkgdir)
            mtree:stage("pkg.mtree", stagedir, "./" .. pkgdir)
            mtree:stage("pkg-bootstrap.mtree", stagedir, "./" .. bootstrapdir)

            local pkgversion = cdruncmd(stagedir, table.unpack(_pkgcmd("rquery", "%v", "pkg")))
            writefile(stagedir .. "/etc/pkg/local.conf", sprintf([[
local: {
    url: "file:///%s",
    signature_type: "none"
}
]], pkgdir))
            mtree:add("./etc/pkg/local.conf")

            writefile(stagedir .. "/etc/rc.local", sprintf([[
if [ -f /firstboot ]; then
    export PATH=${PATH}:/usr/local/sbin:/usr/local/bin
    echo ""
    echo "bricoler: Running first-boot setup"
    # Older version of pkg(7) don't use basename().
    cd /%s/All
    # Install pkg(8).
    IGNORE_OSVERSION=yes pkg add -r local pkg-%s.*
    # Install all the packages we fetched above.
    IGNORE_OSVERSION=yes pkg install -y -r local -g '*'
    if [ $? -ne 0 ]; then
        # There is some pkg bug that requires us to run this twice.
        # Otherwise it'll fail when trying to update the upstream repo.
        IGNORE_OSVERSION=yes pkg install -y -r local -g '*'
    fi
fi
]], bootstrapdir, pkgversion:match("^%s*(.-)%s*$")))
            mtree:add("./etc/rc.local")

            ::pkgdone::
        end

        if self.overlay then
            exec("cp", "-R", self.overlay .. "/", stagedir)
            mtree:stage("overlay.mtree", self.overlay, "")
        end

        local machine, machine_arch = self.build.machine_tuple:match("^(%w+)/(%w+)")
        local image_prefix = pwd() .. "/image." .. machine .. "." .. machine_arch

        -- Create the EFI system partition, if applicable.
        local has_efi = false
        local esp_dir = image_prefix .. "-efi"
        local esp_image = image_prefix .. "-esp.fs"
        do
            if machine == "i386" or machine == "powerpc" then
                goto noefi
            end

            local src = stagedir .. "/boot/loader.efi"
            local targetdir = esp_dir .. "/EFI/BOOT"
            makepath(targetdir)

            local efibins = {
                ["amd64"] = "bootx64.efi",
                ["arm64"] = "bootaa64.efi",
                ["riscv"] = "bootriscv64.efi",
                ["arm"] = "bootarm.efi",
            }
            local efibin = efibins[machine]
            if not efibin then
                errx("No EFI binary for machine tuple %s", machine)
            end
            exec("cp", "-f", src, targetdir .. "/" .. efibin)
            exec("makefs", "-t", "msdos", "-o", "fat_type=16",
                 "-o", "sectors_per_cluster=1",
                 "-o", "volume_label=EFI",
                 "-s", "4m", esp_image, esp_dir)
            has_efi = true

            ::noefi::
        end

        -- Finalize the metalog and write it out, then create the root
        -- filesystem image.
        local fs_image = image_prefix .. ".fs"
        do
            -- Remove the size key from the mtree entries, as they may be
            -- incorrect after file modification.
            mtree:filter(function (entry)
                entry.size = nil
                return entry
            end)
            local metalog = image_prefix .. "-METALOG.mtree"
            mtree:write(metalog)

            local makefs_cmd = {"makefs"}
            if self.filesystem == "ufs" then
                table.append(makefs_cmd,
                    "-t", "ffs",
                    "-Z",
                    "-o", "softupdates=1",
                    "-o", "version=2")
            else
                table.append(makefs_cmd,
                    "-t", "zfs",
                    "-o", "poolname=zroot",
                    "-o", "bootfs=zroot")
            end

            table.append(makefs_cmd,
                "-DD",
                "-s", self.image_size,
                fs_image,
                metalog)
            local oldcwd = cd(stagedir)
            exec(table.unpack(makefs_cmd))
            cd(oldcwd)
        end

        -- Now put everything together and create the disk image.
        do
            self.image = image_prefix .. ".img"
            local mkimg_cmd = {
                "mkimg",
                "-f", "raw",
                "-S", "512",
                "-o", self.image,
            }

            local bootdir = self.build.stagedir .. "/boot"
            if machine == "powerpc" then
                table.append(mkimg_cmd,
                    "-s", "mbr",
                    "-a", "1",
                    "-p", "prepboot:=" .. bootdir .. "/boot1.elf",
                    "-p", "freebsd:=" .. self.image)
            else
                table.append(mkimg_cmd, "-s", "gpt")
                if machine == "amd64" or machine == "i386" then
                    table.append(mkimg_cmd,
                        "-b", bootdir .. "/pmbr",
                        "-p", "freebsd-boot/bootfs:=" .. bootdir .. "/gptboot")
                end
                if has_efi then
                    table.append(mkimg_cmd, "-p", "efi:=" .. esp_image)
                end
                local parttype = self.filesystem == "ufs" and "freebsd-ufs" or "freebsd-zfs"
                table.append(mkimg_cmd,
                    "-p", "freebsd-swap/swap::" .. self.swap_size,
                    "-p", parttype .. "/rootfs:=" .. fs_image)
            end

            exec(table.unpack(mkimg_cmd))
        end
    end,
}

Task{"freebsd-src-vm-image",
    name = "freebsd-src-syzkaller-vm-image",
    description = "Build a FreeBSD VM image suitable for syzkaller",
    parameters = {
        ssh_users = {
            -- syzkaller uses ssh to install the fuzzer into VM instances.
            default = "root",
        },
        rc_kld_list = {
            default = "cryptodev filemon ipsec ng_bluetooth ng_btsocket " ..
                      "ng_hci ng_l2cap pf",
        },
    },
}

Task{
    name = "freebsd-vm-boot",
    description = "Boot a VM running FreeBSD",
    inputs = {
        build = "freebsd-src-build",
        vm_image = "freebsd-src-vm-image",
    },
    parameters = VMRun.task_parameters(),
    outputs = {
        -- The running VM instance.
        VM = "table",
    },

    run = function(self, ctx)
        self.vm_image = self.vm_image:run(ctx)

        local VMparams = {
            image = self.vm_image.image,
            machine_tuple = self.build.machine_tuple,
        }
        for k, _ in pairs(VMRun.task_parameters()) do
            if self[k] then
                VMparams[k] = self[k]
            end
        end
        VMparams.gdb_addr = unused_tcp_port("127.0.0.1")
        VMparams.ssh_addr = unused_tcp_port("127.0.0.1")
        local VM = VMRun(VMparams)

        writefile("./gdb-addr", VM.gdb_addr)
        exec("rm", "-f", "./sysroot")
        exec("ln", "-sf", self.build.stagedir, "./sysroot")
        -- Write out the SSH address for the VM and copy keys from the input
        -- task.  This is ugly but it makes it easier to implement the "ssh"
        -- action.
        writefile("./ssh-addr", VM.ssh_addr)
        exec("rm", "-rf", "./ssh-keys")
        exec("cp", "-R", self.vm_image.ssh_key_directory, "./ssh-keys")

        VM:boot()
        -- The VM's booted to a login prompt.  Hand it off to the inheriting
        -- task.
        self.VM = VM
    end,

    actions = {
        -- Attach gdb to the hypvervisor's debugger stub.
        gdb = function()
            local gdb = which("gdb")
            if not gdb then
                errx("gdb is not in PATH, make sure it is installed")
            end

            local f = io.open_checked("./gdb-addr", "r")
            local val = f:read("*l")
            f:close()

            local sysroot = pwd() .. "/sysroot"
            local addr, port = val:match("^(.*):(%d+)$")
            exec(gdb,
                 "-ex", sprintf("set sysroot %s", sysroot),
                 "-ex", sprintf("file %s/boot/kernel/kernel", sysroot),
                 "-ex", "target remote " .. addr .. ":" .. port)
        end,

        -- SSH into the VM.
        ssh = function()
            local f = io.open_checked("./ssh-addr", "r")
            local val = f:read("*l")
            f:close()

            local addr, port = val:match("^(.*):(%d+)$")
            exec("ssh",
                 "-o", "StrictHostKeyChecking=no",
                 "-o", "UserKnownHostsFile=/dev/null",
                 "-i", pwd() .. "/ssh-keys/id_ed25519_root",
                 "-p", port,
                 "root@" .. addr)
        end,
    }
}

Task{"freebsd-src-vm-image",
    name = "freebsd-src-regression-suite-vm-image",
    description = "Build a VM image set up to run the FreeBSD regression test suite",
    inputs = {
        build = {"freebsd-src-build",
            -- Speed up the build a bit by removing expensive things we don't
            -- need.
            make_arguments = "WITHOUT_CLANG= WITHOUT_LLD= WITHOUT_LLDB= " ..
                             "WITHOUT_LIB32= WITHOUT_LIB64= WITHOUT_ZFS_TESTS=",
        },
    },
    parameters = {
        loader_tunables = {
            default = "net.inet.ip.fw.default_to_accept=1 " ..
                      "net.fibs=8",
        },
        rc_kld_list = {
            -- XXX-MJ fusefs tests silently skip themselves if mac_bsdextended
            -- is loaded.
            default = "accf_data accf_dns accf_http accf_tls " ..
                      "carp cryptodev ctl dummymbuf dummynet fusefs " ..
                      "if_bridge if_enc if_epair if_ovpn if_stf " ..
                      "ipdivert ipfw ipfw ipfw_nat ipl ipsec " ..
                      "mqueuefs " ..
                      "pf pflog pflow pfsync sctp tcpmd5",
        },
        image_size = {
            default = "30g"
        },
        packages = {
            default = "coreutils python python3 devel/py-pytest net/scapy " ..
                      "perl5 jq ksh93 llvm gtar isc-dhcp44-server openvpn " ..
                      "sg3_utils sudo ndisc6 nmap nist-kat git-lite " ..
                      "devel/py-twisted porch gdb"
        },
        ssh_users = {
            -- It's useful to be able to log in to have a look around.
            default = "root",
        },
    },

    run = function(self, ctx)
        self.build = self.build:run(ctx)
        local stagedir = self.build.stagedir
        local mtree = self.build.metalog

        writefile(stagedir .. "/etc/sysctl.conf", [[
kern.ipc.tls.enable=1
vfs.aio.enable_unsafe=1
kern.crypto.allow_soft=1
vm.panic_on_oom=1
]])
        mtree:add("./etc/sysctl.conf")

        mkdir(stagedir .. "/usr/local/bin")
        mtree:add("./usr/local/bin")
        symlink("/usr/local/bin/clang", stagedir .. "/usr/local/bin/cc")
        mtree:add("./usr/local/bin/cc")
        symlink("/usr/local/bin/clang++", stagedir .. "/usr/local/bin/c++")
        mtree:add("./usr/local/bin/c++")
        symlink("/usr/local/bin/clang-cpp", stagedir .. "/usr/local/bin/cpp")
        mtree:add("./usr/local/bin/cpp")

        self:super(ctx)
    end,
}

Task{"freebsd-vm-boot",
    name = "freebsd-src-regression-suite",
    description = "Run the FreeBSD regression test suite inside a VM",
    long_description = [[
This task will run the FreeBSD regression test suite in a VM.  By default,
tests are run in parallel where possible using kyua's parallelism option.

This and the freebsd-src-regression-suite-vm-image task care of various finicky
details to make sure that as many tests as possible can run.  Specifically,
they set various non-default kyua options, install required third-party
packages, and ensure that required kernel modules are loaded.

By default the entire test suite is run.  After kyua completes, it leaves behind
a SQLite database, /root/kyua.db.  This database is used to generate a report of
the test suite run.  The report and the database are copied back to the host, and
the VM is shut down.
]],
    inputs = {
        vm_image = "freebsd-src-regression-suite-vm-image",
    },
    parameters = {
        interactive = {
            -- Overriding this prevents the test from running automatically,
            -- but that can nonetheless be useful when debugging.
            default = false
        },
        ncpus = {
            default = 4
        },
        memory = {
            default = 8 * 1024
        },
        parallelism = {
            -- Defaults to the number of vCPUs.
            description = "The number of tests to run in parallel",
            type = "number",
        },
        count = {
            description = "Number of times to run the specified test(s)",
            default = 1,
        },
        tests = {
            description = "A list of tests to run, relative to /usr/tests",
            type = "string",
            default = "",
        },
    },

    run = function(self, ctx)
        local ndisks = 4
        local disk_dev_list = ""

        -- Add some extra disks for the ZFS tests.
        for i = 1, ndisks do
            local disk = sprintf("./disk%d", i)
            exec("truncate", "-s", "50g", disk)
            self.disk_list = self.disk_list .. " " .. disk

            local disk_dev
            if self.block_driver == "virtio" then
                disk_dev = "vtbd"
            elseif self.block_driver == "ahci" then
                disk_dev = "ada"
            elseif self.block_driver == "nvme" then
                disk_dev = "nda"
            else
                errx("Unknown block driver %s", self.block_driver)
            end

            disk_dev_list = disk_dev_list .. " " .. sprintf("/dev/%s%d", disk_dev, i)
        end

        -- Boot the VM and log in.
        self:super(ctx)

        -- Run the test suite and copy the results back to the host.
        do
            local kyuavars = {
                "-v", "parallelism=" .. (self.parallelism or self.ncpus),
                "-v", "test_suites.FreeBSD.allow_sysctl_side_effects=1",
                "-v", "test_suites.FreeBSD.disks=\"" .. disk_dev_list .. "\"",
                "-v", "test_suites.FreeBSD.fibs=\"0 1 2 3 4 5 6 7\"",
                "-v", "test_suites.FreeBSD.unprivileged_user=tests",
                "--logfile", "/root/kyua.log",
                "--loglevel", "info",
            }
            local dbpath = "/root/kyua.db"
            local kyuacmd = sprintf("kyua %s test -k /usr/tests/Kyuafile -r %s %s",
                                    table.concat(kyuavars, " "), dbpath, self.tests)
            for _ = 1, self.count do
                -- XXX-MJ need to halt if a test fails
                -- kyua refuses to overwrite its output database.
                self.VM:consrun("rm -f /root/kyua.db")
                self.VM:consrun(kyuacmd, 12 * 60 * 60)
            end
            local reportcmd = "kyua report --verbose " ..
                              "--results-filter skipped,xfail,broken,failed " ..
                              "--output=/root/kyua_report.txt " ..
                              "-r /root/kyua.db"
            self.VM:consrun(reportcmd, 60)

            local sshkey = self.vm_image.ssh_key_directory .. "/id_ed25519_root"
            self.VM:scpfrom("root", sshkey, "/root/kyua.db", "./kyua.db")
            self.VM:scpfrom("root", sshkey, "/root/kyua_report.txt", "./kyua_report.txt")
            self.VM:scpfrom("root", sshkey, "/root/kyua.log", "./kyua.log")
        end
    end,

    actions = {
        report = function()
            local f = io.open_checked("./kyua_report.txt", "r")
            for line in f:lines() do
                print(line)
            end
            f:close()
        end,
    }
}

Task{"freebsd-src-vm-image",
    name = "freebsd-src-dtrace-regression-suite-vm-image",
    description = "Build a VM image set up to run the DTrace regression test suite",
    inputs = {
        build = {"freebsd-src-build",
            make_arguments = "WITHOUT_TOOLCHAIN= WITH_DTRACE_TESTS=",
        },
    },
    parameters = {
        rc_kld_list = {
            default = "dtraceall dtrace_test kinst sctp"
        },
        image_size = {
            default = "30g"
        },
        packages = {
            default = "binutils jq libxml2 llvm nmap pdksh perl5",
        },
        ssh_users = {
            -- It's useful to be able to log in to have a look around.
            default = "root",
        },
    },

    run = function (self, ctx)
        self.build = self.build:run(ctx)
        local stagedir = self.build.stagedir
        local mtree = self.build.metalog

        mkdir(stagedir .. "/usr/local/bin")
        mtree:add("./usr/local/bin")
        symlink("/usr/local/bin/clang", stagedir .. "/usr/local/bin/cc")
        mtree:add("./usr/local/bin/cc")
        symlink("/usr/local/bin/clang++", stagedir .. "/usr/local/bin/c++")
        mtree:add("./usr/local/bin/c++")
        symlink("/usr/local/bin/clang-cpp", stagedir .. "/usr/local/bin/cpp")
        mtree:add("./usr/local/bin/cpp")

        self:super(ctx)
    end,
}

Task{"freebsd-src-regression-suite",
    name = "freebsd-src-dtrace-regression-suite",
    description = "Run the DTrace regression test suite inside a VM",
    inputs = {
        vm_image = "freebsd-src-dtrace-regression-suite-vm-image",
    },
    parameters = {
        parallelism = {
            -- Disable parallelism until flaky tests have been fixed.
            default = 1,
        },
        tests = {
            default = "cddl/usr.sbin/dtrace",
        },
    },
}

Task{"freebsd-src-vm-image",
    name = "freebsd-src-stress2-vm-image",
    description = "Build a VM image containing the stress2 test suite",
    inputs = {
        src = "freebsd-src",
    },
    parameters = {
        image_size = {
            default = "50g"
        },
        packages = {
            -- From misc/1st.sh in stress2.
            default = "cdrtools e2fsprogs libmill mDNSResponder ruby",
        },
        ssh_users = {
            -- It's useful to be able to log in to have a look around.
            default = "root",
        },
    },
    outputs = {
        -- The path, relative to the guest filesystem, of the stress2 test
        -- suite.
        stress2_path = "string",
    },

    run = function (self, ctx)
        self.src = self.src:run(ctx)
        self.build = self.build:run(ctx)

        do
            local src = self.src.path .. "/tools/test/stress2"
            local dst = self.build.stagedir .. "/stress2"
            exec("rm", "-rf", dst)
            exec("cp", "-R", src, dst)

            local mtree = self.build.metalog
            mtree:filter(function (entry)
                return not entry.path:match("^/stress2/")
            end)

            mtree:stage("stress2.mtree", self.build.stagedir, "./stress2")
            self.stress2_path = "/stress2"
        end

        self:super(ctx)
    end,
}

Task{"freebsd-vm-boot",
    name = "freebsd-src-stress2",
    description = "Run the stress2 test suite inside a VM",
    long_description = [[

]],
    parameters = {
        interactive = {
            -- Overriding this prevents the test from running automatically,
            -- but that can nonetheless be useful when debugging.
            default = false
        },
        ncpus = {
            default = 4
        },
        memory = {
            default = 16 * 1024
        },
    },
    inputs = {
        vm_image = "freebsd-src-stress2-vm-image",
    },

    run = function(self, ctx)
        self:super(ctx)

        -- Build the test suite helper programs.
        do
            local buildcmd = sprintf("echo root | make -C %s",
                                     self.vm_image.stress2_path)
            self.VM:consrun(buildcmd, 10 * 60)
        end

        -- We want to have a timeout, but it's not clear yet what's reasonable.
        -- A full stress2 run can take days, but we need some way to know
        -- whether it's making progress.  Perhaps there's a watchdog we can use?
        self.VM:consrun(sprintf("make -C %s test", self.vm_image.stress2_path),
                        10 * 24 * 60 * 60)
    end,
}

Task{"freebsd-vm-boot",
    name = "freebsd-src-dev-vm",
    description = "Run a VM with a development environment for FreeBSD",
    inputs = {
        build = "freebsd-src-build",
        vm_image = "freebsd-src-vm-image",
    },
    parameters = {
        interactive = {
            default = true
        },
        ncpus = {
            default = 4
        },
        memory = {
            default = 8 * 1024
        },
    },
}

Task{"git-checkout",
    name = "openzfs-src",
    description = "Fetch the OpenZFS source code",
    parameters = {
        url = {
            default = "https://github.com/openzfs/zfs",
        },
        branch = {
            default = "master",
        },
    }
}

Task{
    name = "openzfs-build",
    description = "Build OpenZFS",
    dependencies = {
        "gmake",
    },
    inputs = {
        src = "openzfs-src",
    },
    outputs = {
        -- A directory containing all of the OpenZFS userspace components.
        user_stagedir = "string",
        -- A directory containing the OpenZFS kernel module.
        kmod_stagedir = "string",
    },
    parameters = {
        clean = {
            description = "Clean the build directory and reconfigure before building",
            default = false,
        },
        configure_args = {
            description = "Extra arguments to pass to configure",
            type = "string",
        },
        sysdir = {
            description = "Path to FreeBSD kernel sources that we're compiling against",
            default = "/usr/src/sys",
        },
    },

    run = function(self, ctx)
        self.src = self.src:run(ctx)

        -- Userspace components are built first, then installed into this
        -- directory.
        local cwd = pwd()
        self.user_stagedir = cwd .. "/install-user"
        mkdir(self.user_stagedir)

        cd(self.src.path)
        if self.clean or not isfile("./configure") then
            exec("./autogen.sh")
        end
        if self.clean or not isfile("./Makefile") then
            if isfile("./Makefile") then
                exec("gmake", "clean")
            end
            local configure_args = {
                "./configure",
                "MAKE=gmake",
                "--with-config=user",
            }
            if self.configure_args then
                for arg in self.configure_args:gmatch("%S+") do
                    table.insert(configure_args, arg)
                end
            end
            exec(table.unpack(configure_args))
        end
        exec("gmake", "-j", ctx.maxjobs, "-s")
        exec("gmake", "install", "DESTDIR=" .. self.user_stagedir)

        -- Now build the kernel module.
        self.kmod_stagedir = cwd .. "/install-kmod"
        mkdir(self.kmod_stagedir)
        cd("module")
        if self.clean then
            exec("make", "-f", "./Makefile.bsd", "clean")
        end
        exec("make", "-j", ctx.maxjobs, "-s", "-f", "./Makefile.bsd",
             "CC=cc",
             "SYSDIR=" .. self.sysdir)
        -- Here we set WITHOUT_DEBUG_FILES to prevent Makefile.bsd from running
        -- mtree.  It has no other effect for FreeBSD kernel modules.
        exec("make", "-s", "-f", "./Makefile.bsd",
             "KMODOWN=" .. _getuid.geteuid(),
             "KMODGRP=" .. _getuid.getegid(),
             "KMODDIR=",
             "DEBUGDIR=",
             "DESTDIR=" .. self.kmod_stagedir,
             "WITHOUT_DEBUG_FILES=",
             "install")
    end
}

Task{"freebsd-src-vm-image",
    name = "openzfs-test-suite-vm-image",
    description = "Build a VM image set up to run the OpenZFS test suite",
    inputs = {
        freebsd_src = "freebsd-src",
        freebsd_build = {"freebsd-src-build",
            make_arguments = "WITHOUT_ZFS= WITHOUT_TOOLCHAIN=",
        },
        openzfs_build = "openzfs-build",
    },
    parameters = {
        filesystem = {
            default = "ufs",
        },
        image_size = {
            default = "30g"
        },
        packages = {
            default = "bash libunwind pamtester sudo",
        },
        ssh_users = {
            -- It's useful to be able to log in to have a look around.
            default = "root",
        },
        sudo_users = {
            default = "tests",
        },
    },

    run = function(self, ctx)
        self.freebsd_src = self.freebsd_src:run(ctx)
        self.freebsd_build = self.freebsd_build:run(ctx)

        do
            self.openzfs_build.sysdir = self.freebsd_src.path .. "/sys"
            self.openzfs_build = self.openzfs_build:run(ctx)

            local stagedir = self.freebsd_build.stagedir

            -- Stage the user bits under /usr/local in the FreeBSD image.
            local ext = "usr/local"
            local src = self.openzfs_build.user_stagedir .. "/" .. ext
            local dst = stagedir .. "/" .. ext
            exec("rm", "-rf", dst)
            makepath(stagedir .. "/" .. libgen.dirname(ext))
            exec("cp", "-R", src, dst)
            local mtree = self.freebsd_build.metalog
            mtree:stage("openzfs.mtree", stagedir, "./" .. ext)

            exec("cp", "-f", self.openzfs_build.kmod_stagedir .. "/openzfs.ko",
                             stagedir .. "/boot/kernel")
            mtree:add("./boot/kernel/openzfs.ko")
            exec("cp", "-f", self.openzfs_build.kmod_stagedir .. "/openzfs.ko.debug",
                             stagedir .. "/usr/lib/debug/boot/kernel/")
            mtree:add("./usr/lib/debug/boot/kernel/openzfs.ko.debug")
        end

        self:super(ctx)
    end,
}

Task{"freebsd-vm-boot",
    name = "openzfs-test-suite",
    description = "Run the OpenZFS test suite inside a VM",
    parameters = {
        interactive = {
            -- Overriding this prevents the test from running automatically,
            -- but that can nonetheless be useful when debugging.
            default = false
        },
        ncpus = {
            default = 4,
        },
        memory = {
            default = 16 * 1024,
        },
        tests = {
            description = "A comma-separated list of tags corresponding to tests to run",
            type = "string",
        },
    },
    inputs = {
        vm_image = "openzfs-test-suite-vm-image",
    },

    run = function(self, ctx)
        -- Add some extra disks for the ZFS tests.
        exec("truncate", "-s", "50g", "./disk1")
        exec("truncate", "-s", "50g", "./disk2")
        exec("truncate", "-s", "50g", "./disk3")
        self.disk_list = "./disk1 ./disk2 ./disk3"

        -- Boot the VM and log in.
        self:super(ctx)

        do
            local cmd = "/usr/local/share/zfs/zfs-tests.sh -v"
            if self.tests then
                cmd = cmd .. " -T " .. self.tests
            end
            local disks = "vtbd1 vtbd2 vtbd3"
            self.VM:consrun(sprintf("DISKS=\"%s\" su -m tests -c \"%s\"", disks, cmd),
                            10 * 24 * 60 * 60)
        end
    end,
}

-------------------------------- Main --------------------------------

if _getuid.geteuid() == 0 then
    errx("bricoler must not be run as root")
end

local function workdir_default()
    local workdir = os.getenv("BRICOLER_WORKDIR")
    if not workdir or workdir == "" then
        workdir = os.getenv("HOME") .. "/bricoler"
    end
    return workdir
end

local Argparse = require 'contrib.argparse'
local parser = Argparse("bricoler", "Manage and run tasks")

local cmds = {}

-- Run a task.
cmds.run = parser:command("run")
                 :description("Run a task")
cmds.run:argument("task")
        :args("?") -- No name means, "print the list of available tasks".
        :description("Task name")
cmds.run:argument("action")
        :args("0-1")
        :description("Optional auxilliary action name")
cmds.run:option("--workdir")
        :description("Working directory")
        :default(workdir_default())
cmds.run:option("-j --maxjobs")
        :description("Maximum number of CPUs to use")
        :default(tostring(sysctl("kern.smp.cpus")))
cmds.run:option("-p --param")
        :description("Set a task parameter")
        :count("*")
cmds.run:flag("-s --show")
        :description("Show the task execution plan")

-- Generate a plain list of tasks, useful for auto-completion.
cmds.list = parser:command("list")
                  :description("List available tasks and task parameters")
cmds.list:argument("task")
         :args("?")
         :description("Task name")

local args = parser:parse()

if args.list then
    if args.task then
        -- Print the parameters for each task.
        local ts = TaskSchedule{
            ctx = {},
            parameters = {},
            target = args.task,
        }
        local names = table.keys(ts.tasks)
        table.sort(names)

        for _, t in ipairs(names) do
            local params = table.keys(tasks[t].parameters)
            table.sort(params)
            for _, p in ipairs(params) do
                print(t .. ":" .. p)
            end
        end
    else
        -- Print a list of tasks.
        local keys = table.keys(tasks)
        table.sort(keys)
        for _, k in ipairs(keys) do
            print(k)
        end
    end
elseif args.run then
    if not args.task then
        print("Available tasks:")
        local keys = table.keys(tasks)
        table.sort(keys)
        for _, k in ipairs(keys) do
            print("  " .. k)
            print("    " .. tasks[k].description)
        end
        os.exit(0)
    end

    local ts = TaskSchedule{
        ctx = {
            action = args.action,
            maxjobs = tonumber(args.maxjobs),
            workdir = args.workdir,
        },
        parameters = args.param,
        target = args.task,
    }

    if args.show then
        ts:show()
    else
        ts:run()
    end
end
