#!/usr/bin/env python3

#
# Copyright (c) Mark Johnston <markj@FreeBSD.org>
#
# SPDX-License-Identifier: BSD-2-Clause
#

import functools
import re
import shutil
import sys
import textwrap
from enum import Enum
from pathlib import Path
from typing import List, Optional, Type, Union

import pexpect

from config import Config
from git import GitRepository
from mtree import MtreeFile
from task import Task, TaskParameter, TaskMeta, TaskSchedule
from util import chdir, host_machine, run_cmd
from vm import VMImage, VMHypervisor, BhyveRun, QEMURun


class FreeBSDSrcRepository(GitRepository):
    def get___FreeBSD_version(self) -> int:
        file = self.path / 'sys' / 'sys' / 'param.h'
        with file.open('r') as f:
            pattern = re.compile(r'^\s*#define\s+__FreeBSD_version\s+(\d+)')
            for line in f:
                match = pattern.match(line)
                if match:
                    return int(match.group(1))
            raise ValueError(
                f"Could not obtain __FreeBSD_version from {file}"
            )

    def make(self, args: List[str], **kwargs):
        cmd = ['make', '-C', self.path.resolve()] + args
        # Don't skip the command if we need to capture output.
        skip = self._no_cmds and not kwargs.get('capture_output', False)
        return run_cmd(cmd, skip=skip, **kwargs)

    @functools.cache
    def machine_targets(self) -> List[str]:
        pattern = re.compile(r'^\s*\w+/\w+$')
        output = self.make(['targets'], capture_output=True).stdout.decode()
        targets = []
        for line in output.splitlines():
            if pattern.match(line.strip()):
                targets.append(line.strip())
        return targets


class GitCheckoutTask(Task):
    name = 'git-checkout'

    parameters = {
        'url': TaskParameter(
            description='URL of the Git repository to clone, or a filesystem path',
            type=str,
            required=True,
        ),
        'branch': TaskParameter(
            description='Branch to check out',
            type=str,
        ),
    }
    outputs = {
        'repo': GitRepository
    }

    def run(self, ctx, repotype: Type[GitRepository] = GitRepository):
        repo = repotype(self.url, Path("./src"), self.branch, no_cmds=self.skip)
        repo.update()
        return {'repo': repo}


class FreeBSDSrcGitCheckoutTask(GitCheckoutTask):
    name = 'freebsd-src-git-checkout'

    url = 'anongit@git.freebsd.org:src.git'
    branch = 'main'

    outputs = {
        'repo': FreeBSDSrcRepository,
        '__FreeBSD_version': int,
    }

    def run(self, ctx):
        outputs = super().run(ctx, repotype=FreeBSDSrcRepository)
        outputs['__FreeBSD_version'] = outputs['repo'].get___FreeBSD_version()
        return outputs


class FreeBSDSrcBuildTask(Task):
    name = 'freebsd-src-build'

    parameters = {
        'clean': TaskParameter(
            description='Clean build directories before building',
            type=bool,
            default=False,
        ),
        'kernel_config': TaskParameter(
            description='Kernel configuration to build',
            type=str,
            default='GENERIC',
        ),
        'machine': TaskParameter(
            description='Target machine architecture',
            type=str,
            default=host_machine(),
        ),
        'make_targets': TaskParameter(
            description='Make targets to build',
            type=str,  # XXX-MJ List[str]
            default=''
        ),
        'objdir': TaskParameter(
            description='Object directory path for the build',
            type=Path,  # XXX-MJ default must be computed after some partial eval
        ),
        'toolchain': TaskParameter(
            description='Toolchain to use for the build',
            type=str,
        ),
    }

    inputs = {
        'src': FreeBSDSrcGitCheckoutTask,
    }

    outputs = {
        'machine': str,
        'metalog': MtreeFile,
        'stagedir': Path,
    }

    def run(self, ctx):
        # See if the user specified a valid target platform.
        if '/' not in self.machine:
            machine = self.machine
            machine_arch = ''
        else:
            (machine, machine_arch) = self.machine.split('/', maxsplit=1)
        targets = self.src.repo.machine_targets()
        if machine_arch == '':
            matches = [target for target in targets if target.startswith(f"{machine}/")]
            if len(matches) == 1:
                machine_arch = matches[0].split('/', maxsplit=1)[1]
            else:
                raise ValueError(
                    f"Multiple architectures found for machine '{machine}': {' '.join(matches)}'"
                )
        if f"{machine}/{machine_arch}" not in targets:
            raise ValueError(
                f"Unknown target platform: {self.machine}"
            )

        objdir = self.objdir
        if objdir is None:
            objdir = Path(f"./obj.{machine}.{machine_arch}").resolve()
        objdir.mkdir(parents=True, exist_ok=True)

        stagedir = Path(f"./stage.{machine}.{machine_arch}").resolve()
        stagedir.mkdir(parents=True, exist_ok=True)

        mtree = MtreeFile()
        for target in self.make_targets.split():
            metalog = stagedir / f"METALOG.{target}.mtree"
            with open(metalog, 'w') as f:
                f.truncate(0)

            args = [
                target,
                "-ss",
                "-j", ctx.max_jobs,
                "-DNO_ROOT",
                f"DESTDIR={stagedir}",
                f"METALOG={metalog}",
                f"TARGET={machine}",
                f"KERNCONF={self.kernel_config}",
            ]
            if self.clean:
                args.append("WITH_CLEAN=")
            else:
                args.append("WITHOUT_CLEAN=")
            if self.toolchain is not None:
                args.append(f"CROSS_TOOLCHAIN={self.toolchain}")

            env = {
                "MAKEOBJDIRPREFIX": objdir,
                "SRCCONF": "/dev/null",
                "__MAKE_CONF": "/dev/null",
            }

            self.src.repo.make(args, env=env)

            mtree.load(metalog, append=True, contents_root=stagedir)

        return {
            'machine': f"{machine}/{machine_arch}",
            'metalog': mtree,
            'stagedir': stagedir,
        }


class FreeBSDSrcBuildAndInstallTask(FreeBSDSrcBuildTask):
    make_targets = "buildworld buildkernel installworld installkernel distribution"


class FreeBSDVMImageFilesystem(Enum):
    UFS = 'ufs'
    ZFS = 'zfs'


class FreeBSDVMImageTask(Task):
    name = 'freebsd-vm-image'

    inputs = {
        'src': FreeBSDSrcGitCheckoutTask,
        'build': FreeBSDSrcBuildAndInstallTask,
    }

    outputs = {
        'image': VMImage,
        'ssh_key_directory': Path
    }

    parameters = {
        'filesystem': TaskParameter(
            description='Filesystem type for the VM image',
            type=FreeBSDVMImageFilesystem,
            default=FreeBSDVMImageFilesystem.UFS,
        ),
        'hostname': TaskParameter(
            description='Hostname for the VM',
            type=str,
            default='freebsd',
        ),
        'image_size': TaskParameter(
            description='Size of the VM image',
            type=str,
            default='10g',
        ),
        'loader_tunables': TaskParameter(
            description='Loader tunables for the VM',
            type=str,  # XXX-MJ Dict[str, str]
            default='',
        ),
        'swap_size': TaskParameter(
            description='Size of the swap partition',
            type=str,
            default='2G',
        ),
    }

    def run(self, ctx):
        machine = self.build.machine
        metalog: MtreeFile = self.build.metalog
        stagedir = self.build.stagedir

        outputs = {}

        # Create ssh keys for the VM.
        outputs['ssh_key_directory'] = Path("./ssh-keys").resolve()
        with chdir(outputs['ssh_key_directory']):
            keyfile = Path("id_ed25519_root").resolve()
            if not keyfile.is_file():
                self.run_cmd(["ssh-keygen", "-t", "ed25519", "-f", str(keyfile), "-N", ""])
            metalog.add_file(keyfile.with_suffix('.pub'),
                             Path("root/.ssh/authorized_keys"))

        def add_config_file(
            _path: Union[Path, str],
            *args,
            source: Optional[Path] = None,
            comment_delimiter: str = "#",
        ) -> None:
            if self.skip:
                return
            path = Path(_path)
            if source is not None:
                shutil.copyfile(source, path)
                mode = "a"
            else:
                mode = "w"
            path.parent.mkdir(parents=True, exist_ok=True)
            with path.open(mode) as f:
                f.write(f"{comment_delimiter} Added by bricoler\n")
                contents = [textwrap.dedent(arg).strip() for arg in args if arg != ""]
                f.write(str.join("\n", contents) + "\n")
            metalog.add_file(path.resolve(), path)

        add_config_file("etc/ssh/sshd_config",
                        "PermitRootLogin without-password",
                        source=(stagedir / "etc/ssh/sshd_config"))

        add_config_file("etc/rc.conf",
                        f"hostname={self.hostname}",
                        "ifconfig_vtnet0=SYNCDHCP",
                        "ifconfig_em0=SYNCDHCP",
                        "defaultroute_delay=2",
                        "sshd_enable=YES",
                        "sshd_rsa_enable=NO",
                        """
                        zfs_enable=YES
                        zpool_reguid=zroot
                        zpool_upgrade=zroot
                        """ if self.filesystem == FreeBSDVMImageFilesystem.ZFS else "")
        add_config_file("etc/fstab",
                        """
                        /dev/gpt/rootfs / ufs rw 1 1
                        """ if self.filesystem == FreeBSDVMImageFilesystem.UFS else "",
                        "none /dev/fd fdescfs rw 0 0")
        add_config_file("boot/loader.conf",
                        "autoboot_delay=1",
                        "console=comconsole",
                        "kern.geom.label.disk_ident.enable=0",
                        "zfs_load=YES" if self.filesystem == FreeBSDVMImageFilesystem.ZFS else "",
                        *[tunable for tunable in self.loader_tunables.split()])

        metalog_path = Path.cwd() / "METALOG.mtree"
        metalog.write(metalog_path)

        image_prefix = f"image.{self.build.machine.replace('/', '.')}"
        esp_image_path = Path.cwd() / f"{image_prefix}-esp.fs"
        fs_image_path = Path.cwd() / f"{image_prefix}.{self.filesystem.value}"
        vm_image_path = Path.cwd() / f"{image_prefix}.img"

        makefs_cmd = ["makefs"]
        if self.filesystem == FreeBSDVMImageFilesystem.UFS:
            makefs_cmd += ["-t", "ffs", "-Z", "-o", "softupdates=1", "-o" "version=2"]
        else:
            makefs_cmd += ["-t", "zfs", "-o", "poolname=zroot", "-o", "bootfs=zroot"]
        makefs_cmd += [
            "-DD",
            "-s", self.image_size,
            fs_image_path,
            metalog_path,
        ]

        with chdir(stagedir):
            self.run_cmd(makefs_cmd)

        has_efi = not (machine.startswith('i386/') or machine.startswith('powerpc/'))
        if has_efi:
            efi_loaders = {
                'amd64': "bootx64.efi",
                'arm': "bootarm.efi",
                'arm64': "bootaa64.efi",
                'riscv': "bootriscv64.efi",
            }
            esp_dir = Path(image_prefix + "-efi")
            shutil.rmtree(esp_dir, ignore_errors=True)
            with chdir(esp_dir / "EFI/BOOT"):
                efi_loader = efi_loaders[machine.split('/')[0]]
                shutil.copyfile(stagedir / "boot/loader.efi", Path(efi_loader))

            makefs_cmd = [
                "makefs",
                "-t", "msdos",
                "-o", "fat_type=16",
                "-o", "sectors_per_cluster=1",
                "-o", "volume_label=EFI",
                "-s", "4m",
                esp_image_path,
                esp_dir,
            ]
            self.run_cmd(makefs_cmd)

        bootdir = stagedir / "boot"
        mkimg_cmd = [
            "mkimg",
            "-f", "raw",
            "-S", 512,
            "-o", vm_image_path,
        ]
        if machine.startswith('powerpc/'):
            mkimg_cmd += [
                "-s", "mbr",
                "-a", "1",
                "-p", f"prepboot:={bootdir / 'boot1.elf'}"
                "-p", f"freebsd:={vm_image_path}",
            ]
        else:
            mkimg_cmd += ["-s", "gpt"]
            if machine.startswith('amd64/') or machine.startswith('i386/'):
                mkimg_cmd += [
                    "-b", f"{bootdir / 'pmbr'}",
                    "-p", f"freebsd-boot/bootfs:={bootdir / 'gptboot'}",
                ]
            if has_efi:
                mkimg_cmd += [
                    "-p", f"efi:={esp_image_path}",
                ]
            mkimg_cmd += [
                "-p", f"freebsd-swap/swap::{self.swap_size}",
                "-p", f"freebsd-{self.filesystem.value}/rootfs:={fs_image_path}",
            ]

        self.run_cmd(mkimg_cmd)

        outputs['image'] = VMImage(vm_image_path, machine)

        return outputs


class FreeBSDVMBootTask(Task):
    name = 'freebsd-vm-boot'

    inputs = {
        'vm_image': FreeBSDVMImageTask,
    }

    parameters = {
        'hypervisor': TaskParameter(
            description='Hypervisor to use for running the VM',
            type=VMHypervisor,
            default=VMHypervisor.QEMU,
        ),
        'interactive': TaskParameter(
            description='Run the VM in interactive mode',
            type=bool,
            default=True,
        ),
        'memory': TaskParameter(
            description='Amount of memory to allocate to the VM',
            type=str,
            default="2048M",
        ),
        'ncpus': TaskParameter(
            description='Number of CPUs to allocate to the VM',
            type=int,
            default=2,
        ),
        'reboot': TaskParameter(
            description='Restart the VM when it exits due to a reboot',
            type=bool,
            default=False,
        ),
    }

    def run(self, ctx):
        cls = QEMURun if self.hypervisor == VMHypervisor.QEMU else BhyveRun
        vmrun = cls(
            image=self.vm_image.image,
            memory=self.memory,
            ncpus=self.ncpus,
        )
        cmd = vmrun.setup()
        if self.interactive:
            self.run_cmd(cmd)
        else:
            child = pexpect.spawn(' '.join(cmd), logfile=sys.stdout.buffer, timeout=300)
            patterns = ["login:", "panic:"]
            pattern = child.expect_exact(patterns)
            if pattern == 1:
                raise RuntimeError("VM panicked during boot")
            child.sendline("root")
            child.expect("root@.*#")

        return {}


#
# Features to add:
# - automatic bisection for build and test failures
# - sending mail upon completion of a task
#   - or, e.g., when syzkaller finds a new report
# - ability to skip dependent tasks
# - tasks to cross-build package repos
#
def main() -> int:
    config = Config()
    try:
        args = config.load(TaskMeta.lookup)
    except ValueError as e:
        print(f"usage error: {e}")
        return 1

    if not args.task:
        if args.show:
            print("Available tasks:")
            for task_name in TaskMeta.task_names():
                print(f"  {task_name}")
            for alias in config.aliases:
                print(f"  {alias['alias']} (alias for {alias['task']})")
            return 0
        elif args.list:
            for task_name in TaskMeta.task_names():
                print(task_name)
            for alias in config.aliases:
                print(alias['alias'])
            return 0
        else:
            config.usage()
            return 1

    if args.alias:
        config.add_alias(args.alias)
        return 0

    sched = TaskSchedule(config)
    if args.show:
        print(f"{sched.target.name}:")
        if len(sched.target.description) > 0:
            print(sched.target.description)
        else:
            print("")
        width = max(len(name) for name in sched.parameters.keys()) + 2
        for name, param in sched.parameters.items():
            print(f"{name+':':<{width}} {param[0].description}")
            print(f"{'':{width+1}}{str(param[1])}")
        return 0
    elif args.list:
        for task in sched.tasks.values():
            for name in task.parameters.keys():
                print(f"{task.name}/{name}")
        return 0
    else:
        sched.run()
        return 0


if __name__ == '__main__':
    sys.exit(main())
